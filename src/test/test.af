.needs <std>
.needs <test>

import {print} from "String" under str;
import string from "String";
import List from "Collections";
import unordered_map from "Collections/unordered_map";
import vector from "Collections/Vector";
import option from "Utils/option";
import {Some, None, optionWrapper} from "Utils/option" under opt;
import {accept, reject, resultWrapper} from "Utils/result" under res;
import Map from "Utils/Map";
import result from "Utils/result";
import {describe, it, assertEqual, assertTrue, fix, getFixture, assertFalse, beforeEach, afterEach, beforeAll, afterAll, itSkip, summary} from "ATest" under test;
import JSON from "JSON";
import { parse } from "JSON/Parse" under parser;
import {String, Number, Boolean, Object, Null, parse} from "JSON" under json;
import Box from "Memory";
import {wrap} from "Memory" under box;

class HookState {
	mutable bool beforeAllRan;
	mutable int beforeEachCount;
	mutable int afterEachCount;
	mutable bool afterAllRan;

	fn init() -> Self {
		my.reset();
		return my;
	};

	fn reset() -> void {
		my.beforeAllRan = false;
		my.beforeEachCount = 0;
		my.afterEachCount = 0;
		my.afterAllRan = false;
	};
};

fn main() -> int{
	test.describe("String", fn () {
        test.it("should get the length of a string", fn () {
            string s = "Hello, World!";
            test.assertEqual(s.len(), 13);
        });

        test.it("should compare two strings", fn () {
            string s1 = "Hello";
            string s2 = "Hello";
            test.assertTrue(s1 == s2);
        });

        test.it("should push a character", fn () {
            string s = new string("abc");
            const let r = s.push('d');
            // test.assertEqual(r.len(), 4);
            test.assertTrue(r == "abcd");
        });

        test.it("should convert to upper and lower", fn () {
            string s = "AfLaT";
            test.assertTrue(s.toLower() == "aflat");
            test.assertTrue(s.toUpper() == "AFLAT");
        });

        test.it("should parse numeric strings", fn () {
            string s = new string("42");
            test.assertTrue(s.isNumeric());
            const let r = s.toInt();
            match r {
                Ok(val) => test.assertEqual(val, 42),
                Err() => test.assertTrue(false)
            };
        });
        
        test.it("should replace characters", fn () {
            string s = "foo bar";
            test.assertTrue(s.replaceChar(' ', '_') == "foo_bar");
        });

        test.it("should create substrings", fn () {
            string s = "hello";
            test.assertTrue(s.subString(1, 4) == "ell");
        });

        return true;
    });

    test.describe("JSON", fn ( ) {
        test.fix("object", fn () {
            let obj = json.Object({
                "name": box.wrap(json.String("John")),
                "age": box.wrap(json.Number(30)),
            });
            return obj;
        });

        test.it("should stringify a JSON object", fn () {
            const JSON obj = test.getFixture("object");
            const let jsonString = obj.stringify();
            test.assertTrue(new string("{\"name\":\"John\",\"age\":30}") == jsonString);
        });

        test.it("should get a field from a JSON object", fn () {
            const JSON obj = test.getFixture("object");
            match obj.get("name") {
                Some(value) => match value.asString() {
                    Ok(s) => test.assertTrue(`John` == s),
                    Err(e) => test.assertEqual(`String`, `Error: {e}`)
                },
                None => test.assertEqual("String", "None")
            }
        });

        test.it("should input a field to a JSON object", fn () {
            JSON obj = test.getFixture("object");
            match obj.set("city", json.String("New York")) {
                Ok(o) => {},
                Err(e) => test.assertEqual(`Object`, `Error: {e}`)
            };

            match obj.get("city") {
                Some(value) => match value.asString() {
                    Ok(s) => test.assertTrue(`New York` == s),
                    Err(e) => test.assertEqual(`String`, `Error: {e}`)
                },
                None => test.assertEqual("String", "None")
            };
        });

        test.describe("json parse", fn () {
            test.it("should parse a JSON string", fn () {
                const string jsonString = new string("\"test\"");
                match json.parse(jsonString) {
                    Ok(value) => {
                        match value.asString() {
                            Ok(s) => {
                                test.assertTrue(`{s}` == `test`);
                            },
                            Err(e) => test.assertEqual(`String`, `Error: {e}`)
                        };
                    },
                    Err(e) => test.assertEqual(`String`, `Error: {e}`)
                };
            });

            test.it("should parse a JSON number", fn () {
                const let jsonString = "42";
                match json.parse(jsonString) {
                    Ok(value) => {
                        match value.asNumber() {
                            Ok(n) => test.assertEqual(n, 42),
                            Err(e) => test.assertEqual(`Number`, `Error: {e}`)
                        };
                    },
                    Err(e) => test.assertEqual(`Number`, `Error: {e}`)
                };
            });

            test.it("should parse a JSON boolean true", fn () {
                const let jsonString = "true";
                match json.parse(jsonString) {
                    Ok(value) => {
                        match value.asBoolean() {
                            Ok(b) => test.assertTrue(b),
                            Err(e) => test.assertEqual(`Boolean`, `Error: {e}`)
                        };
                    },
                    Err(e) => test.assertEqual(`Boolean`, `Error: {e}`)
                };
            });
            
            test.describe("JSON.parse", fn () {
                test.it("should parse directly from a string", fn () {
                    const string jsonString = "\"direct\"";
                    match json.parse(jsonString) {
                        Ok(value) => match value.asString() {
                            Ok(s) => test.assertTrue(`{s}` == "direct"),
                            Err(e) => test.assertEqual(`String`, `Error: {e}`)
                        },
                        Err(e) => test.assertEqual(`String`, `Error: {e}`)
                    };
                });

                test.it("should parse nested objects via JSON.parse", fn () {
                    const string jsonString = "{ \"items\": [1, 2], \"enabled\": true }";
                    match json.parse(jsonString) {
                        Ok(value) => match value.asObject() {
                            Ok(map) => {
                                match map.get("enabled") {
                                    Some(v) => match v.get().asBoolean() {
                                        Ok(flag) => test.assertTrue(flag),
                                        Err(e) => test.assertEqual(`Boolean`, `Error: {e}`)
                                    },
                                    None => test.assertTrue(false)
                                };
                                match map.get("items") {
                                    Some(v) => match v.get().asList() {
                                        Ok(list) => test.assertEqual(list.count(), 2),
                                        Err(e) => test.assertEqual(`List`, `Error: {e}`)
                                    },
                                    None => test.assertTrue(false)
                                };
                            },
                            Err(e) => test.assertEqual(`Object`, `Error: {e}`)
                        },
                        Err(e) => test.assertEqual(`Object`, `Error: {e}`)
                    };
                });
            });
        });
    });

    test.fix("hookState", fn () {
        return new HookState();
    });

    test.describe("ATest hooks", fn () {
        test.beforeAll(fn () {
            HookState state = test.getFixture("hookState");
            state.beforeAllRan = true;
        });

        test.beforeEach(fn () {
            HookState state = test.getFixture("hookState");
            state.beforeEachCount = state.beforeEachCount + 1;
        });

        test.afterEach(fn () {
            HookState state = test.getFixture("hookState");
            state.afterEachCount = state.afterEachCount + 1;
        });

        test.afterAll(fn () {
            HookState state = test.getFixture("hookState");
            state.afterAllRan = true;
        });

        test.it("should run before hooks once", fn () {
            HookState state = test.getFixture("hookState");
            test.assertTrue(state.beforeAllRan);
            test.assertEqual(state.beforeEachCount, 1);
            test.assertEqual(state.afterEachCount, 0);
        });

        test.itSkip("should skip remaining tests", "demonstration");
    });

    test.describe("ATest hook verification", fn () {
        test.it("should run afterAll hook", fn () {
            HookState state = test.getFixture("hookState");
            test.assertTrue(state.afterAllRan);
        });
    });

    test.summary();
};
