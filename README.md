# AFlat
AFlat is a simple, low-level, programming language.  It is designed to give as much freedom as possible to the programmer, and yet at the same time be easy to read and understand. Please see the [documentation](Docs.md) for the full documentation.  Please see examples in the [examples](https://github.com/DeForestt/aflat-chess.git) Repository.
<br>

## Trust the programmer philosophy
AFlat aims to trust that developers know what they are doing.  It allows and encurages things that many other modern languages do not such as pointer arythmatic, memory managment, and so on.

<br>

## Getting started

### One Command to rule them all
Install with one command: 
```
curl -s https://raw.githubusercontent.com/DeForestt/aflat/main/install.sh | bash
```
This will automatically add `aflat` to your `PATH` and enable bash/zsh tab completion.

### Cloning the repository
```bash
git clone https://github.com/DeForestt/aflat
```

### Building the project
The compiler uses **CMake** as its primary build system. Create a build directory and compile with CMake:
```bash
cd aflat
mkdir build && cd build
cmake ..
make
```
For quick rebuilds you can simply run `make` again from the build directory.
After building, generate the standard library objects:
```bash
../rebuild-libs.sh
```
Create an alias to the compiled binary so `aflat` is easy to run:
```bash
alias aflat="<path to build>/bin/aflat"
```
Alternatively add the `bin` directory to your `PATH`.

This readme assumes that the aflat bin directory is in your path or an alias is set.

### Creating a new project
Creating a new aflat project is as simple as running the binary with the command `make`
```bash
aflat make <project_name>
```
To create a library project omit the hello world `main` by using `--lib`:
```bash
aflat --lib make <project_name>
```
Every project scaffold now ships with a README that explains the core `aflat`
commands (`build`, `run`, `test`, and `docs`). Regenerate or create one any time
with:
```bash
aflat readme [path] [project_name]
```

### Hello World
The hello world program in aflat is auto-generated by the `make` command.
```js
.needs <std>

import * from "io" under io;

int main(){
    io.print("Hello World!");
    return 0;
};
```

### Building a project
The `aflat make` command generates an `aflat.cfg` file that describes how the
package manager should build your project. The configuration uses an INI style
format with a `[build]` section for settings like the entry point and output
binary as well as an optional `[dependencies]` section for additional modules.
```bash
aflat build
```

### Including dependencies
Add modules under `[dependencies]` in `aflat.cfg`. Each entry can be a relative
path to a `.af` file or a Git repository URL. Use `aflat install <repo>` to clone
a Git dependency and automatically update the configuration. Example:

```ini
[dependencies]
collections = "./src/collections.af"
logger = "https://github.com/example/logger.git"
```

### Running the project
Build and run the project with the `aflat run` command.

### Inspecting code and libraries
Use the `aflat docs` command to list classes, functions, unions, and transforms
defined in either your sources or the standard library:
```bash
aflat docs src/main.af
aflat docs libraries/std/src/String.af
```
This is the fastest way to explore what a module exposes without opening the
source directly.

### Best Practices
* Format C++ code with clang-format using
  `find . \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) -exec clang-format -i {} +`.
* Use CMake for the compiler build and `make` for quick rebuilds.
* After editing files in `libraries/std/src`, run `./rebuild-libs.sh`.
* Run `./bin/aflat run` to execute tests and ensure changes work as expected.
* Regenerate README instructions with `aflat readme` so collaborators always
  see up-to-date workflow details.

### Array Loop Example
```js
.needs <std>

import {printInt, printChar} from "io" under io;
import ICollection, Array from "Collections";

int main(){
    Array a = new Array(int, 10);
    for int i = 0; i < 10; i = i + 1 {
        adr pointer = a.at(i);              // adr - is the pointer 'address' key word
        pointer =: i;                       // the =: operator is used to load a value to a pointer
    };

    a.forEach([adr value]=> io.printInt(value as int)); // the as operator is used to assume the type of a pointer
	io.printChar('\n');
    return 0;
};
```

## Have fun!
