# AFlat
AFlat is a simple, low-level, programming language.  It is designed to give as much freedom as possible to the programmer, and yet at the same time be easy to read and understand. Please see the [documentation](Docs.md) for the full documentation.  Please see examples in the [examples](https://github.com/DeForestt/aflat-chess.git) Repository.
<br>

## Trust the programmer philosophy
AFlat aims to trust that developers know what they are doing.  It allows and encurages things that many other modern languages do not such as pointer arythmatic, memory managment, and so on.

<br>

## Getting started

### One Command to rule them all
Install with one command: 
```
curl -s https://raw.githubusercontent.com/DeForestt/aflat/main/install.sh | bash
```
This will automatically add `aflat` to your `PATH` and enable bash/zsh tab completion.

### Cloning the repository
```bash
git clone https://github.com/DeForestt/aflat
```

### Building the project
The compiler uses **CMake** as its primary build system. Create a build directory and compile with CMake:
```bash
cd aflat
mkdir build && cd build
cmake ..
make
```
For quick rebuilds you can simply run `make` again from the build directory.
After building, generate the standard library objects:
```bash
../rebuild-libs.sh
```
Create an alias to the compiled binary so `aflat` is easy to run:
```bash
alias aflat="<path to build>/bin/aflat"
```
Alternatively add the `bin` directory to your `PATH`.

This readme assumes that the aflat bin directory is in your path or an alias is set.

### Creating a new project
Creating a new aflat project is as simple as running the binary with the command `make`
```bash
aflat make <project_name>
```
To create a library project omit the hello world `main` by using `--lib`:
```bash
aflat --lib make <project_name>
```
Every project scaffold now ships with a README that explains the core `aflat`
commands (`build`, `run`, `test`, and `docs`). Regenerate or create one any time
with:
```bash
aflat readme [path] [project_name]
```

### Hello World
The hello world program in aflat is auto-generated by the `make` command.
```js
.needs <std>

import * from "io" under io;

int main(){
    io.print("Hello World!");
    return 0;
};
```

### Building a project
The `aflat make` command generates an `aflat.cfg` file that describes how the
package manager should build your project. The configuration uses an INI style
format with a `[build]` section for settings like the entry point and output
binary as well as an optional `[dependencies]` section for additional modules.
```bash
aflat build
```

### Including dependencies
Add modules under `[dependencies]` in `aflat.cfg`. Each entry can be a relative
path to a `.af` file or a Git repository URL. Use `aflat install <repo>` to clone
a Git dependency and automatically update the configuration. Example:

```ini
[dependencies]
collections = "./src/collections.af"
logger = "https://github.com/example/logger.git"
```

### Running the project
Build and run the project with the `aflat run` command.

### Inspecting code and libraries
Use the `aflat docs` command to list classes, functions, unions, and transforms
defined in either your sources or the standard library:
```bash
aflat docs src/main.af
aflat docs libraries/std/src/String.af
```
This is the fastest way to explore what a module exposes without opening the
source directly.

### Standard library overview
AFlat ships a batteries-included standard library under `libraries/std`. The
modules below are the most commonly used building blocks:

#### Runtime & strings
- `std` - Arena allocator, `malloc`/`free`, `memcpy`, `panic`, `sleep`, and other intrinsics (libraries/std/src/std.af).
- `std-cmp` - Compatibility shim that swaps in libc memory helpers plus panic/assert when the arena can't be used (libraries/std/src/std-cmp.af).
- `Memory` - RefCounted base class alongside the generic `Box`/`wrap` helpers for owning values (libraries/std/src/Memory.af).
- `String` - Assembly-backed string primitive covering allocation, slicing, iteration, comparisons, casing, and conversions (libraries/std/src/String.af).
- `strings` - Standalone utilities such as `len`, concat, ASCII helpers, and int/float parsing/formatting (libraries/std/src/strings.af).
- `System` - Thin syscall wrappers for `execve`, `exec`, shell execution, and environment-variable helpers (libraries/std/src/System.af).

#### Numerics & IO
- `math` - Numeric helpers including `Random`, integer/float exponentiation, square roots, conversions, and absolute values (libraries/std/src/math.af).
- `io` - Terminal IO functions for reading strings, printing chars/ints/hex, and emitting ANSI-colored output (libraries/std/src/io.af).
- `files` - File descriptor wrapper with `FileError`/`ReadError`, buffered reads, iterators, and write helpers (libraries/std/src/files.af).
- `DateTime` - Epoch-based `DateTime` struct with parsing, getters, formatting, and day-of-week math (libraries/std/src/DateTime.af).

#### Collections & iteration
- `Collections` - Generic `List` implementation with push/pop/find helpers and bounds-checked access (libraries/std/src/Collections.af).
- `Collections/Vector` - Type-parametric `vector` supporting copy/move semantics, iterators, sorting, and optional accessors (libraries/std/src/Collections/Vector.af).
- `Collections/unordered_map` - Hash-tree-backed associative container with `set`/`get`/`keys` and Option-aware lookups (libraries/std/src/Collections/unordered_map.af).
- `Collections/Iterator` - Base iterator abstraction plus `Next`/`Peek` decorators to wire callbacks (libraries/std/src/Collections/Iterator.af).
- `Collections/Enumerator` - Adds index-aware enumeration and exposes the numeric `Range` iterator (libraries/std/src/Collections/Enumerator.af).
- `Collections/Scroller` - List-backed iterator that yields sequential elements with peek support (libraries/std/src/Collections/Scroller.af).
- `Collections/Tuple` - Value-type tuples with ownership-safe destruction and `make_tuple` helper (libraries/std/src/Collections/Tuple.af).

#### Data modeling & serialization
- `JSON` - Tagged union covering JSON primitives, casting helpers, mutation, and pretty printing (libraries/std/src/JSON.af).
- `JSON/Parse` - Wrapper that routes to `JSON.parse` for turning strings into JSON values (libraries/std/src/JSON/Parse.af).
- `JSON/Property` - Reserved module for future JSON/property bindings (libraries/std/src/JSON/Property.af).

#### HTTP & networking
- `HTTP` - HTTP errors, verb enum, request parser, `HTTPMessage`/`HTTPResponse`, and `listen` helper (libraries/std/src/HTTP.af).
- `HTTP/Endpoint` - Endpoint wrapper/registry plus pluggable NotFound handler (libraries/std/src/HTTP/Endpoint.af).
- `HTTP/Endpoints` - Sugar classes for registering GET/POST/PUT/DELETE/etc. handlers (libraries/std/src/HTTP/Endpoints.af).
- `HTTP/Server` - Middleware-aware server that dispatches endpoints, supports wildcards, and formats error responses (libraries/std/src/HTTP/Server.af).
- `HTTP/Middleware` - Before/after middleware registration helper applied per request (libraries/std/src/HTTP/Middleware.af).
- `request.c` - C shim exposing `request`, `_aflat_server_spinUp`, and `serve` socket utilities (libraries/std/src/request.c).

#### Utility types & error handling
- `Utils/Option` - Ref-counted Option class with `resolve`, `match`, and defaulting helpers (libraries/std/src/Utils/Option.af).
- `Utils/option` - Lightweight union mirroring Rust's Option with `Some`/`None` constructors (libraries/std/src/Utils/option.af).
- `Utils/Result` - Class-based result value for bridging APIs that expect dynamic success/error payloads (libraries/std/src/Utils/Result.af).
- `Utils/result` - Rust-style `result<T>` union with ergonomic constructors and unwrap helpers (libraries/std/src/Utils/result.af).
- `Utils/Error` - Base `Error` class with type metadata, render hooks, and pattern matching (libraries/std/src/Utils/Error.af).
- `Utils/Error/Render` - Decorator that lets errors plug in a render callback (libraries/std/src/Utils/Error/Render.af).

#### Utility infrastructure & patterns
- `Utils/Functions` - Capturing function wrapper that invokes stored callbacks with optional captures (libraries/std/src/Utils/Functions.af).
- `Utils/Defer` - RAII helper that runs a `Function` when the object leaves scope unless dismissed (libraries/std/src/Utils/Defer.af).
- `Utils/Map` - Tree-backed map with hashing, normalization, and Option-returning lookups (libraries/std/src/Utils/Map.af).
- `Utils/Object` - Dynamic object base with type tagging, validation hooks, and match support (libraries/std/src/Utils/Object.af).
- `Utils/Properties` - Property decorators (`computed`, `readonly`, `lazy`, `observable`, `clamped`, `with`) plus supporting classes (libraries/std/src/Utils/Properties.af).
- `Utils/Observable` - Observer list that notifies subscribers when events fire (libraries/std/src/Utils/Observable.af).

#### Tooling & frameworks
- `ATest` - BDD-style testing DSL with fixtures, describe contexts, hooks, and reporting helpers (libraries/std/src/ATest.af).
- `concurrency` - Process/thread abstractions (`Process`, `MProcess`), message pipes, and `AsyncResult` handles (libraries/std/src/concurrency.af).
- `CLArgs` - Command-line parser with long/short flags, typed values, validation, and help text (libraries/std/src/CLArgs.af).
- `Web/Content` - File-backed templating utility that applies bindings before rendering (libraries/std/src/Web/Content.af).
- `Web/Content/Bind` - Binding helper that registers template placeholders and preprocessors (libraries/std/src/Web/Content/Bind.af).

### Best Practices
* Format C++ code with clang-format using
  `find . \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) -exec clang-format -i {} +`.
* Use CMake for the compiler build and `make` for quick rebuilds.
* After editing files in `libraries/std/src`, run `./rebuild-libs.sh`.
* Run `./bin/aflat run` to execute tests and ensure changes work as expected.
* Regenerate README instructions with `aflat readme` so collaborators always
  see up-to-date workflow details.

### Array Loop Example
```js
.needs <std>

import {printInt, printChar} from "io" under io;
import ICollection, Array from "Collections";

int main(){
    Array a = new Array(int, 10);
    for int i = 0; i < 10; i = i + 1 {
        adr pointer = a.at(i);              // adr - is the pointer 'address' key word
        pointer =: i;                       // the =: operator is used to load a value to a pointer
    };

    a.forEach([adr value]=> io.printInt(value as int)); // the as operator is used to assume the type of a pointer
	io.printChar('\n');
    return 0;
};
```

## Have fun!
