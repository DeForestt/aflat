.needs <std>

import Function from "Utils/Functions";
import Map from "Utils/Map";
import Option from "Utils/Option";
import string from "String";

types(T)
union option {
  Some(T),
  None

  safe fn isSome() -> bool {
    match my {
      Some() => return true,
      None() => return false
    };
  };

  safe fn isNone() -> bool {
    match my {
      Some() => return false,
      None() => return true
    };
  };

  safe fn expect(const string msg) -> T {
    match my {
      Some(value) => return value,
      None() => {
        panic(msg.cstr());
      }
    };
  };

  safe fn or(const T defaultValue) -> T {
    match my {
      Some(value) => return value,
      None() => return defaultValue
    };
  };

  safe fn toString() -> string {
    match my {
        Some(value) => return `Some({value.toString()})`,
        None() => return `None`
    };
  };

};

types(T)
export fn Some(const T val) -> option::<T> {
  return new option::<T>->Some(val);
};

types(T)
export fn None() -> option::<T> {
  return new option::<T>->None();
};