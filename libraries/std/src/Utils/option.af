.needs <std>
import {print} from "String" under str;
import string from "String" under str;

types(T)
union option {
  Some(T),
  None

  safe fn isSome() -> bool {
    match my {
      Some() => return true,
      None() => return false
    };
  };

  safe fn isNone() -> bool {
    match my {
      Some() => return false,
      None() => return true
    };
  };

  safe fn expect(const string msg) -> T {
    match my {
      Some(value) => return value,
      None() => {
        panic(msg.cstr());
      }
    };
  };

  safe fn unwrap() -> T {
    match my {
      Some(value) => return value,
      None() => {
        panic("Called unwrap on a None value");
      }
    };
  };

  safe fn or(const T &&defaultValue) -> T {
    match my {
      Some(value) => return value,
      None() => return defaultValue
    };
  };

  safe fn toString() -> string {
    match my {
      Some(value) => return `Some({value})`,
      None() => return "None"
    }
  }
};

types(T)
export fn Some(const T val) -> option::<T> {
  return new option::<T>->Some(val);
};

types(T)
export fn None() -> option::<T> {
  return new option::<T>->None();
};

types(T)
export fn optionWrapper(immutable T value) -> option::<T> {
  const adr checker = NULL;
  const adr cpoint = ?checker;
  cpoint =: value;
  if (checker == NULL) {
    return new option::<T>->None();
  } else {
    return new option::<T>->Some(value);
  }
};