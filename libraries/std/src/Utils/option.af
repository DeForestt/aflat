.needs <std>

import Function from "Utils/Functions";
import Map from "Utils/Map";
import Option from "Utils/Option";
import string from "String";

types(T)
union option {
  Some(T),
  None

  safe fn isSome() -> bool {
    match my {
      Some() => return true,
      None() => return false
    };
  };

  safe fn isNone() -> bool {
    match my {
      Some() => return false,
      None() => return true
    };
  };

  safe fn expect(const string msg) -> T {
    match my {
      Some(value) => return value,
      None() => {
        panic(msg.cstr());
      }
    };
  };

  safe fn or(const T defaultValue) -> T {
    match my {
      Some(value) => return value,
      None() => return defaultValue
    };
  };

  safe fn toString() -> string {
    match my {
        Some(value) => return `Some({value.toString()})`,
        None() => return `None`
    };
  };

};

types(T)
export fn Some(const T val) -> option::<T> {
  return new option::<T>->Some(val);
};

types(T)
export fn None() -> option::<T> {
  return new option::<T>->None();
};

// !UNSAFE! This function is not typesafe
// Alert: This function practicas type erasure
private bool nullIsh(immutable any value) {
  return value == NULL;
};

types(T)
export fn toOption(immutable T value) -> option::<T> {
    if nullIsh(value) {
        return option::<T>->None();
    } else {
        return option::<T>->Some(value);
    };
};
