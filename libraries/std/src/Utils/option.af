.needs <std>
import {print} from "String" under str;
import string from "String" under str;

types(T)
/**
 * Optional value container inspired by Rust's Option. Wraps a `Some(T)` or
 * sentinel `None` and provides ergonomic helpers for safe unwrapping.
 */
union option {
  Some(T),
  None

  safe fn isSome() -> bool {
    match my {
      Some() => return true,
      None() => return false
    };
  };

  safe fn isNone() -> bool {
    match my {
      Some() => return false,
      None() => return true
    };
  };

  safe fn expect(const string msg) -> T {
    match my {
      Some(value) => return value,
      None() => {
        panic(msg.cstr());
      }
    };
  };

  safe fn unwrap() -> T {
    match my {
      Some(value) => return value,
      None() => {
        panic("Called unwrap on a None value");
      }
    };
  };

  safe fn or(const T &&defaultValue) -> T {
    match my {
      Some(value) => return value,
      None() => return defaultValue
    };
  };

  safe fn toString() -> string {
    match my {
      Some(value) => return `Some({value})`,
      None() => return "None"
    }
  }
};

types(T)
// Wrap a value in the `Some` variant for ergonomic construction.
export fn Some(const T val) -> option::<T> {
  return new option::<T>->Some(val);
};

types(T)
// Obtain a typed `None` value for the requested generic parameter.
export fn None() -> option::<T> {
  return new option::<T>->None();
};

types(T)
/**
 * Wrap an arbitrary value by probing whether it represents NULL when cast to
 * an adr, mirroring aflat's implicit optional semantics.
 */
export fn optionWrapper(immutable T value) -> option::<T> {
  const adr checker = NULL;
  const adr cpoint = ?checker;
  cpoint =: value;
  if (checker == NULL) {
    return new option::<T>->None();
  } else {
    return new option::<T>->Some(value);
  }
};
