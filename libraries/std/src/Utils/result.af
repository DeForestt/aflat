.needs <std>
import string from "String";
import Error from "Utils/Error";

types(T)
/**
 * Result type that carries either `Ok(T)` success values or `Err(Error)`
 * failures, closely mirroring Rust's Result ergonomics.
 */
union result {
    Ok(T),
    Err(Error)

    safe fn expect(const string msg) -> T {
        match my {
            Ok(value) => return value,
            Err(err) => {
                panic(`Error: {err}. {msg}`.cstr());
            }
        };
    };

    safe fn unwrap() -> T {
        match my {
            Ok(value) => return value,
            Err(err) => {
                panic(`Error: {err}`.cstr());
            }
        };
    };

    safe fn expectErr(const string msg) -> Error {
        match my {
            Ok(_) => {
                panic(`Expected error but got Ok. {msg}`.cstr());
            },
            Err(err) => return err
        };
    };

    safe fn unwrapErr() -> Error {
        match my {
            Ok(_) => {
                panic("Expected error but got Ok");
            },
            Err(err) => return err
        };
    };

    safe fn isOk() -> bool {
        match my {
            Ok() => return true,
            Err() => return false
        };
    };

    safe fn isErr() -> bool {
        match my {
            Ok() => return false,
            Err() => return true
        };
    };

    safe fn toString() -> string {
        match my {
            Ok(value) => return `Ok({value})`,
            Err(err) => return `Err({err})`
        }
    }
};

types(T)
// Convenience constructor for building an `Ok` from a value.
export fn accept(const T value) -> result::<T> {
    return new result::<T>->Ok(value);
};

types(T)
// Convenience constructor for building an `Err` from an Error.
export fn reject(const Error err) -> result::<T> {
    return new result::<T>->Err(err);
};

types(T)
/**
 * Wraps a move-only value when interfacing with APIs that expect `result<T>`
 * responses, defaulting to `Ok` semantics.
 */
export fn resultWrapper(const T value) -> result::<T> {
    return new result::<T>->Ok(value);
};
