.needs <std>

import string from "String";
import Error from "Utils/Error";

types(A)
union result {
  Ok(A),
  Err(Error)

  safe fn expect() -> A {
    match my {
      Ok(value) => return value,
      Err(err) => {
        panic(`Error: {err}`.cstr());
      }
    };
  };

  safe fn getError() -> Error {
    match my {
      Ok() => return NULL,
      Err(err) => return err
    };
  };

  safe fn hasError() -> bool {
    match my {
      Ok() => return false,
      Err() => return true
    };
  };

  safe fn toString() -> string {
    match my {
      Ok(value) => return `Ok: {value}`,
      Err(err) => return `Error: {err}`
    };
  };


};

types(T)
export fn accept(const T value) -> result::<T> {
  return new result::<T>->Ok(value);
};

types(J)
export fn reject(const Error error) -> result::<J> {
  return new result::<J>->Err(error);
};
