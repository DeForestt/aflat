.needs <std>

import string from "String";
import Error from "Utils/Error";

types(T)
union result {
    Ok(T),
    Error(Error)

    fn expect() -> T {
        match {
            Ok(value) => return value,
            Error(err) => panic(`Unhandled error: {err}`.cstr())
        };
    };

    fn getError() -> Error {
        match {
            Ok() => return Error("No error".cstr()),
            Error(err) => return err
        };
    };

    fn hasError() -> bool {
        match {
            Ok() => return false,
            Error() => return true
        };
    };

    fn toString() -> string {
        match {
            Ok(value) => return `Ok({value})`,
            Error(err) => return `Error({err})`
        };
    };
};

types(T)
export fn accept(const T value) {
    return new result->Ok(value);
};

types(T)
export fn reject(const Error err) {
    return new result::<T>->Error(err);
};