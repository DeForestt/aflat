.needs <std>
import Map from "Utils/Map";
import Option from "Utils/Option";
import List from "Collections";
import Scroller from "Collections/Scroller";
import Function from "Utils/Functions";
import Observable from "Utils/Observable";

import {print, printHex} from "io" under io;

/*
 * Decorate a class method to be treated as a read-only calculated property.
 */
safe dynamic class Computed {
    private const any<any> foo = foo;
    private const any context = context;

    Computed init(const any<any> foo, const any context){
        const int __i = 0;
        return my;
    };

    any get() {
        const let foo = my.foo;
        return foo(my.context);
    };
};


/*
 * Decorate a class method to be treated as a read-write calculated property.
 * This property is observable.
 */
 @Apply(Observable)
safe dynamic class Property {
    private mutable any<any> getter;
    private mutable void<any, any> setter;
    private const any context = context;

    Property init(const Map<> foo, const any context) {
        const Map access = foo();
        my.getter = access.get("get").or(NULL);
        my.setter = access.get("set").or(NULL);
        return my;
    };

    any get() {
        const let getter = my.getter;
        if (getter == NULL) panic("Attempt to read from a property without a getter.");
        return getter(my.context);
    };

    void _set(const any value) {
        const let setter = my.setter;
        if (setter == NULL) panic("Attempt to write to a property without a setter.");
        setter(my.context, value);
        my.notify(my);
    };

    adr ref() {
        return my;
    };
};

transform observable 
~
mutable ${type} __${ident} = ${expr};
fn ${ident}() -> Map : Property {{
	"get": [const ${Self} this] => {
		return this.__${ident};
	},
	"set": [const ${Self} this, const ${type} x] => {
		this.__${ident} = x;
		return;
	}
}};
~;

transform readonly 
~
private mutable ${type} __${ident} = ${expr};
fn ${ident}() -> Map : Property {{
    "get": [const ${Self} this] => {
        return this.__${ident};
    },
    "set": [] => {
        panic("Cannot set readonly property");
        return;
    }
}};
~;

transform computed 
~
fn ${ident}() -> adr : Property {{
    "get": [const ${Self} my] => {
        return ${expr};
    },
    "set": [] => {
        panic("Cannot set computed property");
        return;
    }
}};
~;

transform lazy 
~
private mutable ${type} __${ident} = NULL;
fn ${ident}() -> Map : Property {{
    "get": [const ${Self} this] => {
        if (this.__${ident} == NULL) {
            this.__${ident} = ${expr};
        }
        return this.__${ident};
    },
    "set": [] => {
        panic("Cannot set lazy property");
        return;
    }
}};
~;