.needs <std>
.needs <asm>
.needs <request>

import List from "Collections";
import String, string from "String";
import {len, int_toString} from "strings" under str;
import {print, printInt, fPrint, printHex} from "io" under io;
import {worker} from "concurrency" under async;
import {printString, fString} from "String" under st;

enum HTTPMethod {
    GET,
    POST,
    PUT,
    DELETE,
    HEAD,
    OPTIONS,
    TRACE,
    CONNECT
};


export adr methodToString(HTTPMethod method) {
    if method == HTTPMethod.GET 
        return "GET"
    else if method == HTTPMethod.POST
        return "POST"
    else if method == HTTPMethod.PUT
        return "PUT"
    else if method == HTTPMethod.DELETE
        return "DELETE"
    else if method == HTTPMethod.HEAD
        return "HEAD"
    else if method == HTTPMethod.OPTIONS
        return "OPTIONS"
    else if method == HTTPMethod.TRACE
        return "TRACE"
    else if method == HTTPMethod.CONNECT
        return "CONNECT"
    else
        return "UNKNOWN";
};

class HTTPHeader {
    const adr key = key;
    const adr value = value;

    HTTPHeader init(adr key, adr value) {
        return my;
    };
};

class HTTPMessage {
    const private List headers = new List(HTTPHeader);
    private bool switch = false;
    string origin = new string("");
    string body = new string("");
    string version;
    string statusCode;
    string statusMessage;

    private int parse(adr rsi) {
        string rsp = new string(rsi);
        my.origin = rsp;

        let lines = rsp.split('\r');
        string firstLine = lines.get(0);
        firstLine.trim();
        let firstLineParts = firstLine.split(' ');

        if (firstLineParts.getCount() < 3) {
            
            io.fPrint("First line of response is invalid: %s \nlist size: %d\n", {firstLine, firstLineParts.getCount()});
            return -1;
        };
        my.version = firstLineParts.get(0);
        my.statusCode = firstLineParts.get(1);
        my.statusMessage = firstLineParts.get(2);

        for int i = 3; i < firstLineParts.getCount(); i++ {
            my.statusMessage = st.fString("%s %s", {my.statusMessage, firstLineParts.get(i)});
        };

        my.switch = false;

        lines.forEach([string line, int index, HTTPMessage this] => {
            if line == "\n" {
                this.switch = true;
                return 0;
            };
            
            if index == 0
                return 0;

            if this.switch {
                this.body = this.body + line + "\r\n";
                return 0;
            };

            let sections = line.split(':');
            if sections.getCount() < 2{
                io.fPrint("Invalid header: %s\n", {line});
                return 0;
            };

            string key = sections.get(0);
            string value = sections.get(1);

            if sections.getCount() > 2 {
                for int i = 2; i < sections.getCount(); i = i + 1 {
                    value = value + ":";
                    string t = sections.get(i);
                    value = value + t;
                };
            };
            key = key.trim();
            value = value.trim();
            HTTPHeader n = new HTTPHeader(key.cstr(), value.cstr());
            this.headers.pushBack(n);
        }, my);
        return 0;
    };


    HTTPMessage init(adr rsp) {
        my.parse(rsp);
        return my;
    };

    
    adr getHeader(adr key) {
        adr args = malloc(adr);
        args =: key;
        my.headers.forEach([HTTPHeader header, int index, adr arg] => {
            adr comp = arg as adr;
            String a = new String(header.key);
            a = a.trim('\n');
            a = a.trim('\r');
            a = a.trim();
            if a.equal(comp) {
                arg =: header.value;
                delete a;
                return 1;
            };
            delete a;
        }, args);
        adr ret = args as adr;
        return ret;
    };
};

class HTTPRequest {
    const private HTTPMethod method = method;
    private adr host;
    private adr endpoint;
    const private List headers = new List(HTTPHeader);
    private adr body = "\r\n";

    HTTPRequest init(HTTPMethod method) {
        my.host = "";
        my.endpoint = "/";
        return my;
    };

    int setHost(adr host) {
        my.host = host;
        return 0;
    };

    int setEndpoint(adr endpoint) {
        my.endpoint = endpoint;
        return 0;
    };

    int addHeader(adr key, adr value) {
        HTTPHeader header = new HTTPHeader(key, value);
        my.headers.pushBack(header);
    };

    int setBody(adr body) {
        my.body = body;
        adr contentLen = malloc(10);
        int size = str.len(body);
        str.int_toString(size, contentLen);
        my.addHeader("Content-Length", contentLen);
    };

    public string getHeaders() {
        string res = new string("");
        my.headers.forEach([HTTPHeader header, int i, string buffer] => {
            buffer = buffer + header.key;
            buffer = buffer + ": ";
            buffer = buffer + header.value;
            buffer = buffer + "\r\n";
            buffer.get();
            return 0;
        }, res);
        return res;
    };

    string toString() {
        string res = new string("");
        res = res + methodToString(my.method);
        res = res + " ";
        res = res + my.endpoint + " HTTP/1.1";
        res = res + "\r\nHost: ";
        res = res + my.host;
        res = res + "\r\n";
        res = res + my.getHeaders();
        res = res + "\r\n";
        res = res + my.body;
        return res;
    };

    HTTPMessage send(int bufferSize) {
        string msg = my.toString();
        adr buffer = malloc(bufferSize);
        adr host = my.host;
        adr endpoint = my.endpoint;
        adr msg_prim = msg.cstr();
        request(host, endpoint, "80", msg_prim, buffer, bufferSize);
        let res = new string(buffer);
        return new HTTPMessage(buffer);
    };
};

export adr requestWorker(HTTPRequest _arg) : async.worker {
    return _arg.send(10000000);
};
