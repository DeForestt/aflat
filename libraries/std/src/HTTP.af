.needs <std>
.needs <asm>
.needs <request>

import LinkedList from "Collections";
import String from "String";
import {len, int_toString} from "strings" under str;
import {print, printInt} from "io" under io;
import {worker} from "concurrency" under async;
import {printString} from "String" under st;

enum HTTPMethod {
    GET,
    POST,
    PUT,
    DELETE,
    HEAD,
    OPTIONS,
    TRACE,
    CONNECT
};


export adr methodToString(HTTPMethod method) {
    if method == HTTPMethod.GET 
        return "GET"
    else if method == HTTPMethod.POST
        return "POST"
    else if method == HTTPMethod.PUT
        return "PUT"
    else if method == HTTPMethod.DELETE
        return "DELETE"
    else if method == HTTPMethod.HEAD
        return "HEAD"
    else if method == HTTPMethod.OPTIONS
        return "OPTIONS"
    else if method == HTTPMethod.TRACE
        return "TRACE"
    else if method == HTTPMethod.CONNECT
        return "CONNECT"
    else
        return "UNKNOWN";
};

class HTTPHeader {
    const adr key = key;
    const adr value = value;

    HTTPHeader init(adr key, adr value) {
        return my;
    };
};

class HTTPResponce {
    const private LinkedList headers = new LinkedList();
    private bool switch = false;
    String origin = origin;
    String body = new String("");
    String version;
    String statusCode;
    String statusMessage;

    int parse(String rsp) {
        LinkedList lines = rsp.split('\r');
        String firstLine = lines.get(0);
        firstLine.trim();
        LinkedList firstLineParts = firstLine.split(' ');

        if (firstLineParts.size() != 3) {
            io.print("\n\nFirst line of HTTP response is not valid: ");
            st.printString(firstLine);
            io.print("\n");
            io.printInt(firstLineParts.size());
            io.print("\n");
            return -1;
        };
        my.version = firstLineParts.get(0);
        my.statusCode = firstLineParts.get(1);
        my.statusMessage = firstLineParts.get(2);
        my.switch = false;

        lines.forEach([String line, int index, HTTPResponce this] => {
            if line.equal("\n") {
                this.switch = true;
                return 0;
            };
            
            if index == 0
                return 0;

            if this.switch {
                this.body = this.body.concat(line);
                this.body = this.body.stitch("\r");
                return 0;
            };

            LinkedList sections = line.split(':');
            if sections.size() < 2{
                io.print("\n\nHeader line is not valid: ");
                st.printString(line);
                io.print("\n");
                return 0;
            };

            String key = sections.get(0);
            String value = sections.get(1);

            if sections.size() > 2 {
                for int i = 2; i < sections.size(); i = i + 1 {
                    value = value.stitch(":");
                    value = value.concat(sections.get(i));
                };
            };
            key = key.trim();
            value = value.trim();
            HTTPHeader n = new HTTPHeader(key.getPrimitive(), value.getPrimitive());
            this.headers.append(n);
        }, my);
        return 0;
    };

    HTTPResponce init(* String origin) {
        if origin != NULL
            my.parse(origin);
        return my;
    };

    adr getHeader(adr key) {
        adr args = malloc(adr);
        args =: key;
        my.headers.forEach([HTTPHeader header, int index, adr arg] => {
            adr comp = arg as adr;
            String a = new String(header.key);
            a = a.trim('\n');
            a = a.trim('\r');
            a = a.trim();
            if a.equal(comp) {
                arg =: header.value;
                delete a;
                return 1;
            };
            delete a;
        }, args);
        adr ret = args as adr;
        return ret;
    };
};

class HTTPRequest {
    const private HTTPMethod method = method;
    private adr host;
    private adr endpoint;
    const private LinkedList headers = new LinkedList();
    private adr body = "\r\n";

    HTTPRequest init(HTTPMethod method) {
        my.host = "";
        my.endpoint = "/";
        return my;
    };

    int setHost(adr host) {
        my.host = host;
        return 0;
    };

    int setEndpoint(adr endpoint) {
        my.endpoint = endpoint;
        return 0;
    };

    int addHeader(adr key, adr value) {
        HTTPHeader header = new HTTPHeader(key, value);
        my.headers.append(header);
    };

    int setBody(adr body) {
        my.body = body;
        adr contentLen = malloc(10);
        int size = str.len(body);
        str.int_toString(size, contentLen);
        my.addHeader("Content-Length", contentLen);
    };

    public String getHeaders() {
        String res = new String("");
        my.headers.forEach([HTTPHeader header, int i, adr strptr] => {
            String buffer = strptr as String;
            buffer = buffer.stitch(header.key);
            buffer = buffer.stitch(": ");
            buffer = buffer.stitch(header.value);
            buffer = buffer.stitch("\r\n");
            strptr =: buffer;
            return 0;
        }, ?res);
        return res;
    };

    String toString() {
        String res = new String("");
        res = res.stitch(methodToString(my.method));
        res = res.stitch(" ");
        res = res.stitch(my.endpoint);
        res = res.stitch(" ");
        res = res.stitch("HTTP/1.1");
        res = res.stitch("\r\n");
        res = res.stitch("Host: ");
        res = res.stitch(my.host);
        res = res.stitch("\r\n");
        res = res.concat(my.getHeaders());
        res = res.stitch("\r\n");
        res = res.stitch(my.body);
        return res;
    };

    HTTPResponce send(int bufferSize) {
        String msg = my.toString();
        adr buffer = malloc(bufferSize);
        adr host = my.host;
        adr endpoint = my.endpoint;
        adr msg_prim = msg.getPrimitive();
        request(host, endpoint, "80", msg_prim, buffer, bufferSize);
        String res = new String(buffer);
        free(buffer);
        HTTPResponce rsp = new HTTPResponce(res);
        return rsp;
    };
};

export adr requestWorker(HTTPRequest _arg) : async.worker {
    return _arg.send(10000000);
};
