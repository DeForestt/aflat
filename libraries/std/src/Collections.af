 .needs <Collections.gs>
 .needs <std.gs>
 .needs <io>

/*
 * function name: NewList;
 * description:   create a new list;
 * arguments:     none;
 * returns:       a new list;
 */
 LinkedList newList(){
    LinkedList list = malloc(LinkedList);
    list.init();
    return list;
 };

 /*
 * function name:   forEach@LinkedList;
 * description:     iterates through the list and calls the given function on each node
                    it will break if the function returns 1;
 * agruments:       adr foo : the function to be called on each node
 *                  adr arg : the argument to be passed to the function;
 * returns:         int : 0 if successful, -1 if not;
 */
int forEachLinkedList(LinkedList my, adr foo, adr arg){
    ListNode curr;
    curr = my.head;
    int i = 0;
    while(curr != #0){
        adr data;
        data = curr.data;
        int cont = foo(data, i, arg);
        if(cont == 1){
            return 1;
        };
        curr = curr.next;
        i = i + 1;
    };
    return 0;
};

Array whereLinkedList(LinkedList my, adr foo, adr arg){
    Array a = newArray(adr, 0);

    ListNode curr;
    curr = my.head;
    int i = 0;
    while(curr != #0){
        adr data;
        data = curr.data;
        int boo = foo(data, i, arg);
        if(boo == 1){
            a.extend(1);
            int size;
            size = a.size;
            size = size - 1;
            adr point;
            point = a.at(size);
            point =: data;
        };
        curr = curr.next;
        i = i + 1;
    };
    return a;
};

/*
 * function name: init@LinkedList;
 * description:   initialize a list;
 * arguments:     none;
 * returns:       none;
 */

int init@LinkedList(){
    my.head = #0;
    my.forEach = forEachLinkedList;
    my.where = whereLinkedList;
    return 0;
};

/*
 * function name: newNode;
 * description:   create a new node;
 * arguments:     none;
 * returns:       a new node;
 */

ListNode newNode(){
    ListNode node = malloc(ListNode);
    node.data = #0;
    return node;
};

/*
 * function name:   remove@LinkedList;
 * description:     removes the node at the given index;
 * agruments:       int index : the index of the node to remove;
 * returns:         int : 0 if successful, -1 if not;
 */

int delete@LinkedList(int index){
    ListNode curr;
    curr = my.head;

    int i = 0;
    while(i < index){
        curr = curr.next;
        i = i + 1;
    };
    curr = curr.next;
    return 0;
};

int stitch@LinkedList(LinkedList new){
    ListNode curr;
    curr = my.head;
    while(curr.next != #0){
        curr = curr.next;
    };
    curr.next = new.head;
    return 0;
};

/*
 * function name:   get@LinkedList;
 * description:     returns the node at the given index;
 * agruments:       int index : the index of the node to return;
 * returns:         adr : the node at the given index;
 */

adr get@LinkedList(int index){
    if (index < 0){
        return #0;
    };
    ListNode myHead;
    myHead = my.head;
    ListNode myIndex;
    myIndex = myHead;

    int i = 0;
    while(i < index){
        myIndex = myIndex.next;
        i = i + 1;
    };

    return myIndex.data;
};

/*
 * function name:   append@LinkedList;
 * description:     appends a node to the end of the list;
 * agruments:       adr data : the data to be appended;
 * returns:         int : 0 if successful, -1 if not;
 */

int append@LinkedList(adr data){
    ListNode new = newNode();
    new.data = data;

    if(my.head == #0){
        my.head = new;
        return 0;
    };

    ListNode curr;
    curr = my.head;
    
    while(curr.next != #0){
        curr = curr.next;
    };

    curr.next = new;
    return 0;
};

/*
 * function name:   insert@LinkedList;
 * description:     inserts a node at the given index;
 * agruments:       int index : the index to insert the node at
 *                  adr data : the data to be inserted;
 * returns:         int : 0 if successful, -1 if not;
 */
int insert@LinkedList(int index, adr data){
    if (index < 0){
        return -1;
    };

    ListNode new = newNode();
    new.data = data;

    ListNode curr;
    curr = my.head;
    
    for{int i = 0}(i < index){i = i + 1}{
        curr = curr.next;
    };

    adr temp;
    temp = curr.next;
    new.next = temp;
    curr.next = new;
    return 0;
};

/*
 * function name:   size@LinkedList;
 * description:     returns the size of the list;
 * agruments:       none
 * returns:         int : the size of the list;
 */

int size@LinkedList(){
    ListNode curr;
    curr = my.head;
    int i = 0;
    while(curr != #0){
        curr = curr.next;
        i = i + 1;
    };
    return i;
};


/*
 * function name:   forEach@Array;
 * description:     preforms a function for each element of the array passed by value
                    it will break if the function returns 1;
 * arguments:       foo : a function pointer to call on the elements
                    arg : an argument pointer;
 * returns:         int: 0 if sucssesfull, 1 on error
 */
int forEachArray(Array my, adr foo, adr arg){
    int size;
    size = my.size;
    adr element;
    int tSize;
    tSize = my.typeSize;
    adr curr;

    int i;
    for {i = 0;}(i < size){i = i + 1}{
        int offset = i * tSize;
        curr = my.head;
        curr = curr + offset;
        int brk = foo(curr, i, arg);
        if (brk == 1){
            return 0;
        };
    };
    return 0;
};

Array whereArray(Array my, adr foo, adr arg){
    Array a = newArray(adr, 0);
    int size;
    adr tSize;
    tSize = my.typeSize;
    size = my.size;
    int i;
    for {i = 0;}(i < size){i = i + 1}{
        int offset = i * tSize;
        adr curr;
        curr = my.head;
        curr = curr + offset;
        adr save; save = curr;
        int boo = foo(curr, i, arg);
        if (boo == 1){
            a.extend(1);
            int msize;
            msize = a.size;
            msize = msize - 1;
            adr point = a.at(msize);
            point =: save;
        };
    };
    return a;
};

/*
 * function name: init@Array;
 * description:   initialize an array;
 * arguments:     int typeSize : the size of the type
 *                int size : the size of the array;
 * returns:       0 if successful, -1 if not;
 */
int init@Array(int typeSize, int size){
    my.size = size;
    my.typeSize = typeSize;
    
    size = size * typeSize;
    my.head = malloc(size);
    my.forEach = forEachArray;
    my.where = whereArray;
    return 0;
};

/*
 * function name:   at@Array;
 * description:     returns the address of the element at the given index;
 * agruments:       int index : the index of the element to return;
 * returns:         adr : the address of the element at the given index;
 */
adr at@Array(int index){
    int tSize;
    tSize = my.typeSize;
    int offset = index * tSize;
    adr curr;
    curr = my.head;
    curr = curr + offset;
    return curr;
};

/*
  * function name: newArray;
  * description:   create a new array;
  * arguments:     int typeSize : the size of the type
  *                int size : the size of the array;
  * returns:       Array : a new array
  */
Array newArray(int typeSize, int size){
    Array my = malloc(Array);
    my.init(typeSize, size);
    return my;
};

/*
 * function name:   delete@Array;
 * description:     deletes the array and frees the memory;
 * arguments:       none;
 * returns:         int :  0;
 */
int delete@Array(){
    free(my.head);
    free(my);
    return 0;
};

/*
 * function name:   extend@Array;
 * description:     extends the array by the given amount;
 * arguments:       int amount : the amount to extend the array by;
 * returns:         int size : the new size of the array;
 */
int extend@Array(int amount){
    adr curr;
    curr = my.head;
    int currSize;
    currSize = my.size;
    my.size = currSize + amount;

    int tSize;
    tSize = my.typeSize;

    amount = amount + currSize;
    amount = amount * tSize;

    my.head = realloc(curr, amount);
    if(my.head == #0){
        print("badrealloc");
    };
    return  amount;
};