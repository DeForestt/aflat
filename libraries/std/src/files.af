.needs <std.gs>
.needs <asm.gs>

import {len} from "strings" under str;
import string from "String";
import {print} from "String" under st;
import {printLong, printHex, printInt, print} from "io" under io;
import result from "Utils/result";
import Error from "Utils/Error";
import Render from "Utils/Error/Render";
import { accept, reject, resultWrapper } from "Utils/result" under res;
import option from "Utils/option";
import {Some, None} from "Utils/option" under opt;
import vector from "Collections/Vector";


fn strerror(int code) -> adr;

// Error wrapper for failures encountered when opening files.
class FileError signs Error {
        int code = code * -1;

        private string renderMessage() : Render {
                const adr myStr = strerror(my.code);
                return `Failed To Open File Error Code ({my.code}): {myStr}`;
        };

        fn init(const int code) -> FileError {
                return my;
        };
};

// Error wrapper for read failures (including EOF conditions).
class ReadError signs Error {
        private int code = code * -1;
        private string renderMessage() : Render {
                if(my.code == -1) {
                        return `End of File Reached`;
                };
                const adr myStr = strerror(my.code);
                return `Failed To Read File Error Code ({my.code}): {myStr}`;
        };

        fn init(const int code) -> ReadError {
                return my;
        };
};

private int clearChar(adr pointer, const int size){
        int i = 0;
        while(i < size){
                pointer =: '\0';
                pointer = pointer + 1;
                i = i + 1;
        };
};

/**
 * File descriptor wrapper with convenience helpers for reading, iterating,
 * and writing text/bytes.
 */
class File{
    adr fileName;
    int file;
    bool it;

    fn write(const adr text) -> int {
        const int length = str.len(text);
        const int ret = sys_write(my.file, text, length);
        return ret;
    };

    fn writeBytes(const adr pointer, const int size) -> void {
        sys_write(my.file, pointer, size);
    };

    fn read(adr pointer, const char delim) -> int {
        const char input = '\0';
        const char null = '\0';
        while(input != delim){
                const int eof = sys_read(my.file, ?input, 1);
                char inp;
                inp = input;
                pointer =: inp;
                if(inp == delim){pointer =: null};
                if(eof == 0){pointer =: null; return 1};
                pointer = pointer + #1;
        };
        pointer =: null;
        return  0;
    };

    fn toVector(const char delim) -> vector::<string> {
        const let l = new vector::<string>();
        const char[256] ibuff;
        
        int eof = my.read(ibuff, delim);

        while (eof != 1){
                l.push_back(new string(ibuff));
                clearChar(ibuff, 256);
                eof = my.read(ibuff, delim);
        };

        l.push_back(new string(ibuff));
        return l;
    };

    fn next() -> option::<string> {
        if !my.it {
            return opt.None::<string>();
        };
        const char[256] ibuff;
        const int eof = my.read(ibuff, '\n');
        if (eof == 0) {
            return opt.Some(new string(ibuff));
        } else {
            my.it = false;
            return opt.Some(new string(ibuff));
        };
    };

    fn readToEnd() -> result::<string> {
        const int file = my.file;
        const long current = sys_lseek(file, 0, 1); // SEEK_CUR
        if current < 0 {
            return res.reject::<string>(new ReadError(0 + current));
        };
        const long endPos = sys_lseek(file, 0, 2); // SEEK_END
        if endPos < 0 {
            return res.reject::<string>(new ReadError(0 + endPos));
        };
        const long remaining = endPos - current;
        const long reset = sys_lseek(file, current, 0); // SEEK_SET
        if reset < 0 {
            return res.reject::<string>(new ReadError(0 + reset));
        };
        if remaining <= 0 {
            return res.reject::<string>(new ReadError(1));
        };
        const int size = 0 + remaining;
        const adr buffer = malloc(1 + size);
        const int err = sys_read(file, buffer, size);
        if err < -1 {
            const let extra = buffer;
            free($extra);
            return res.reject::<string>(new ReadError(err));
        } else if err == 0 {
            const let extra = buffer;
            free($extra);
            return res.reject::<string>(new ReadError(1));
        };
        const adr pointer = buffer + err;
        pointer =: '\0';
        const string text = new string(buffer);
        free($buffer);
        return res.accept(text);
    };

    fn close() -> int {
        return sys_close(my.file);
    };

    fn rewind() -> void {
        sys_seek(my.file, 0, 0); // SEEK_SET
    };

    fn toString() -> string {
        return `[File]`;
    };
};

// Create or truncate a file for read/write access, returning File! result.
export fn createFile(const adr fileName) -> File! {
        const File file = malloc(File);
        const long flag = #2 | #512 | #64; // O_RDWR | O_CREAT | O_TRUNC
        file.file = sys_open(fileName, flag, 0o0777);
        file.it = true;
        const int test = file.file;
        if(test < 1) {
                const let extra = file;
                free($extra);
                return res.reject::<File>(new FileError(test));
        };

        return file;
};

// Open an existing file for read/write access, returning File! result.
export fn openFile(const adr fileName) -> File! {
        const File file = malloc(File);
        const long flag = #2;
        file.file = sys_open(fileName, flag, 0o0777);
        file.it = true;
        const int test = file.file;
        if(test < 0){
                const let extra = file;
                free($extra);
                return res.reject::<File>(new FileError(test));
        };
        file.fileName = fileName;
        return file;
};


safe dynamic pedantic class FileManager {
  private mutable int refcount = 1;
  private mutable bool usable = true;

  private mutable File f = NULL;

  FileManager init(const adr filename) {
    my.f = match createFile(filename) {
        Ok(file) => file,
        Err() => {
            my.usable = false;
        }
    };
    return my;
  };
  
  int del() {
        if (my.usable) {
                my.f.close();
                delete my.f;
        };
        return 0;
  };
  
  File _call() {
    if !my.usable {
        // undefined behavior
        panic("Attempted to use an unusable file");  
    };
    my.refcount = my.refcount - 1;
    return my.f;
  };

  void endScope() {
    my.refcount = my.refcount - 1;
    if (my.refcount == 0) {
      my.del();
      free($my);
    };
  };
  
  FileManager get() {
    my.refcount = my.refcount + 1;
    return my;
  };

  FileManager cpy<<=>>(const FileManager other) {
        if (my.usable) {
            my.f.close();
            delete my.f;
        };
        my.f = other.f;
        my.usable = other.usable;
        // invalidate the other
        other.usable = false;
        other.f = NULL;
        return my;
  };

};
