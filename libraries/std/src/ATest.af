.needs <std>
.needs <asm>

import {print, printInt, fPrint} from "io" under io;
import {print as strPrint} from "String" under str;

int passes = 0;
int failures = 0;

adr _beforeAll = NULL;
adr _afterAll = NULL;
adr _beforeEach = NULL;
adr _afterEach = NULL;

class Expect {
    private any value = value;

    Expect init(const any value) {
        return my;
    };

    bool toBe(const any expected) {
        if my.value == expected {
            return true;
        } else {
            return false;
        };
    };

    bool toEqual(const any expected) {
        return my.toBe(expected);
    };
};

export Expect expect(const any value) {
    return new Expect(value);
};

export void beforeAll(const adr fn) { _beforeAll = fn; };
export void afterAll(const adr fn) { _afterAll = fn; };
export void beforeEach(const adr fn) { _beforeEach = fn; };
export void afterEach(const adr fn) { _afterEach = fn; };

export void describe(const adr name, const adr fn) {
    strPrint(`\n${name}\n`);
    if _beforeAll != NULL { const let f = _beforeAll; f(NULL, NULL, NULL, NULL); };
    fn(NULL, NULL, NULL, NULL);
    if _afterAll != NULL { const let f = _afterAll; f(NULL, NULL, NULL, NULL); };
};

export void test(const adr name, const adr fn) {
    if _beforeEach != NULL { const let f = _beforeEach; f(NULL, NULL, NULL, NULL); };
    strPrint(`  ${name}: `);
    const bool result = fn(NULL, NULL, NULL, NULL);
    if result {
        io.print("OK\n", 'g');
        passes = passes + 1;
    } else {
        io.print("FAIL\n", 'r');
        failures = failures + 1;
    };
    if _afterEach != NULL { const let f = _afterEach; f(NULL, NULL, NULL, NULL); };
};

export int report() {
    io.print("Passed: "); io.printInt(passes); io.print("\n");
    io.print("Failed: "); io.printInt(failures); io.print("\n");
    return failures;
};

class Mockable {
    private adr impl = impl;
    private adr mockImpl = NULL;
    private bool useMock = false;
    private int callCount = 0;

    Mockable init(const adr impl) {
        return my;
    };

    void mock(const adr fn) {
        my.mockImpl = fn;
        my.useMock = true;
    };

    void unMock() {
        my.useMock = false;
        my.mockImpl = NULL;
    };

    any _call(const adr ref, *const any a, *const any b, *const any c, *const any d) {
        my.callCount = my.callCount + 1;
        const let f = if my.useMock my.mockImpl else my.impl;
        return f(ref, a, b, c, d);
    };

    bool wasCalled() {
        return my.callCount > 0;
    };

    int getCallCount() {
        return my.callCount;
    };

    void resetCallCount() {
        my.callCount = 0;
    };

    void reset() {
        my.resetCallCount();
        my.unMock();
    };
};
