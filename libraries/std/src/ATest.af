.needs <std>
.needs <asm>
import {print, printInt, fPrint} from "io" under io;
import LinkedList from "Collections";
import String, string from "String";
import {printString, print} from "String" under str;

// keep track of passes and failures
int passes = 0;
int failures = 0;

int requiresPass = 0;
int requiresFail = 0;

export bool case(adr foo, adr _arg) {
	bool result = foo(_arg);

	if result {
		io.print("OK\n", 'g');
        passes = passes + 1;
	} else {
		io.print("FAIL\n", 'r');
        failures = failures + 1;
	};
    
    if requiresPass > 0
        str.print(`{requiresPass} requires passed.\n`);

    if requiresFail > 0
        str.print(`{requiresFail} requires failed.\n`);
        
    for int i = 0; i < requiresFail; i++ {
        io.print("-", 'r');
    };
    
    for int i = 0; i < requiresPass; i++ {
        io.print("+", 'g');
    };

    io.print("\n----------------------------------------------------\n");
    requiresPass = 0;
    requiresFail = 0;
    return result;
};

export bool require(bool result, string describe) {
    if result {
        requiresPass = requiresPass + 1;
        return true;
    } else {
        io.fPrint("\n\tTest require: %s: ", {describe});
        io.print("FAIL\n", 'r');
        requiresFail = requiresFail + 1;
        return false;
    };
};

export int report() {
    io.print("Passed tests: "); io.printInt(passes); io.print("\n");
    io.print("Failed tests: "); io.printInt(failures); io.print("\n");

    for int i = 0; i < failures; i++ {
        io.print("-", 'r');
    };
    
    for int i = 0; i < passes; i++ {
        io.print("+", 'g');
    };
    io.print("\n");
    
    if failures > 0 {
        sys_write(2, " ", 1);
        return 1;
    } else {
        return 0;
    };
};

class TestSuite {
    private LinkedList cases = new LinkedList();
    private LinkedList args = new LinkedList();
    private adr beforeAll = beforeAll;
    private adr cleanup = cleanup;
    adr fixture = NULL;

    string name = new string(name);

    TestSuite init(adr name, * adr beforeAll, * adr cleanup) {
        return my;
    };

    void setFixture(adr fixture) {
        my.fixture = fixture;
    };

    int addCase(adr foo, adr _arg) {
        my.cases.append(foo);
        my.args.append(_arg);
        return 0;
    };

    int run() {
        str.print(`\n\nRunning test suite: {my.name}\n\n\n`);
        for int i = 0; i < my.cases.size(); i++ {
            adr foo = my.cases.get(i);
            adr _arg = my.args.get(i);
            str.print(`Running test case: {_arg}: `);
            if my.beforeAll != NULL {
                let beforeAll = my.beforeAll;
                beforeAll(my.fixture);
            };

            foo(my.fixture);
        };
        return 0;
    };

    void del() {
        delete my.cases;
        delete my.args;
        if my.cleanup != NULL {
            let cleanup = my.cleanup;
            cleanup(my.fixture);
        };
    };

};

class Mockable {
	private adr foo = foo;
	private adr mockImpl = NULL;
	private bool mock = false;
	private int callCount = 0;

	Mockable init(adr foo) {
		return my;
	};

	void mock(adr mockImpl) {
		my.mockImpl = mockImpl;
		my.mock = true;
	};

	void unMock() {
		my.mock = false;
		my.mockImpl = NULL;
	};

	any _call(adr ref, * any arg1, * any arg2, * any arg3, * any arg4) {
		my.callCount = my.callCount + 1;
		let mockImpl = my.mockImpl;
		let foo = my.foo;
		if (my.mock) {
			return mockImpl(ref, arg1, arg2, arg3, arg4);
		} else {
			return foo(ref, arg1, arg2, arg3, arg4);
		};
	};

	bool wasCalled() {
		return my.callCount > 0;
	};

	int getCallCount() {
		return my.callCount;
	};

	void resetCallCount() {
		my.callCount = 0;
	};

	void reset() {
		my.resetCallCount();
		my.unMock();
	};
};