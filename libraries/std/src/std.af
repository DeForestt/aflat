.needs <std.gs>
.needs <asm.gs>
.needs <io>

Block head = NULL;

//helpers

Block findFreeBlock(Block last, int size) {
  Block current;
  current = head;
  size = size - 1;
  while (current != NULL) {
    if(current.free == 1){
        if (current.size > size){return current};
    };

    current = current.next;
  };
  return NULL;
};

Block requestSpace(Block last, int size){
    Block block = brk(0);
    int nsize = size + Block;
    adr i = brk(block + nsize);

    if(i < #0){return NULL};

    if (last != NULL){
        last.next = block;
    };
    block.next = NULL;
    block.size = size;
    block.free = 0;

    return block;
};

Time newTime(adr count){
    Time this = malloc(Time);
    this.amount = count;
    return this;
};

Block getBlock(adr ptr){
    ptr = ptr - Block;
    return ptr;
};

//Interface
int memcopy (adr from, adr to, int size){
    int i = 0;
    while(i < size){
        byte b = from as byte;
        to =: b;
        to = to + #1;
        from = from + #1;
        i = i + 1;
    };
    return 0;
};


int free(adr ptr){
    if(ptr == NULL){
        return 0;
    };
    
    Block block = getBlock(ptr);
    block.free = 1;

    return 0;
};

adr malloc(int size){

    Block block;

    if(size < 0){return NULL};

    if(head == #0){
        block = requestSpace(#0, size);
        head = block;
        block = block + #16;
        return block;
    };
    Block last;
    last = head;

    // loop through the list to the last block
    while(last.next != NULL){
        last = last.next;
    };

    block = findFreeBlock(head, size);
    if (block == #0){
        block = requestSpace(last, size);
        if(block == #0){return #0};
    };
    block.free = 0;
    block = block + Block;
    return block;
};

adr realloc(adr ptr, int size){
    if (ptr == #0){
        return malloc(size);
    };

    Block block = getBlock(ptr);
    int nsize = size - 1;
    if(block.size > nsize){
        return ptr;
    };
    
    adr new_ptr = malloc(size);
    if (new_ptr == #0){return #0;};
    int bsize;
    bsize = block.size;
    memcopy(ptr, new_ptr, bsize);
    free(ptr);
    return new_ptr;
};

int inspectHeap(){
    Block current;
    current = head;
    print("Heap:\n");
    print("HEAD --> ");
    while (current != NULL){
        printHex(current); print(": status: ");
        printInt(current.free); print(" size: ");
        printInt(current.size); print("\n");
        current = current.next;
        print("         ");
    };
    print("NULL\n");
    return 0;
};

Bit newBit(int value){
	Bit b = malloc(Bit);
	b.value = value;
	b.last = NULL;
	b.next = NULL;
	return b;
};

Times newTimes(){
    Times t = malloc(Times);
    t.tms_cstime = 0;
    t.tms_cutime = 0;
    t.tms_stime = 0;
    t.tms_utime = 0;
    return t;
};