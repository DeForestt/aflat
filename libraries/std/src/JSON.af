.needs <std>
import string from "String";
import result from "Utils/result";
import option from "Utils/option";
import vector from "Collections/Vector";
import unordered_map from "Collections/unordered_map";
import {Some, None, optionWrapper} from "Utils/option" under opt;
import {accept, reject, resultWrapper} from "Utils/result" under res;
import {print} from "String" under str;
import {char_isDigit, char_isWhiteSpace} from "strings" under st;
import {hex_toInt} from "strings" under st;
import {len} from "strings" under st;
import {toChar, toInt} from "io" under io;
import Box from "Memory";
import {wrap} from "Memory" under box;
import Error from "Utils/Error";

/**
 * Dynamically typed JSON value supporting rich constructors plus convenience
 * methods to cast to native aflat types.
 */
union JSON {
    String(adr),
    Number(int),
    Boolean(bool),
    List(vector::<Box::<JSON>>),
    Object(unordered_map::<Box::<JSON>>),
    Null

    fn get(const string key) -> JSON? {
        match my {
            Object(map) => {
                match map.get(key.cstr()) {
                    Some(value) => return value.get(), // unwrap the Box
                    None => return NULL // null will become None
                }
            },
            _ => return NULL,
        };
    };

    fn set(const string key, const JSON value) -> JSON! {
        match my {
            Object(map) => {
                map.set(key.cstr(), new Box::<JSON>(value));
                return my;
            },
            _ => return new Error("JSON is not an Object")
        }
    };

    fn asString() -> adr! {
        match my {
            String(s) => return s,
            _ => return new Error("JSON is not a String")           
        }
    };

    fn asNumber() -> int! {
        match my {
            Number(n) => return n,
            _ => return new Error("JSON is not a Number")
        }
    };

    fn asBoolean() -> bool! {
        match my {
            Boolean(b) => return b,
            _ => return new Error("JSON is not a Boolean")
        }
    };

    fn asList() -> vector::<Box::<JSON>>! {
        match my {
            List(list) => return list,
            _ => return new Error("JSON is not a List"),
        }
    }; 

    fn asObject() -> unordered_map::<Box::<JSON>>! {
        match my {
            Object(map) => return map,
            _ => return new Error("JSON is not an Object")
        }
    };

    fn isNull() -> bool {
        match my {
            Null => return true,
            _ => return false
        }
    };

    fn toString() -> string {
        match my {
            String(s) => return `String({s})`,
            Number(n) => return `Number({n})`,
            Boolean(b) => return `Boolean({b})`,
            List(list) => return `List({list})`,
            Object(map) => return `Object({map})`,
            Null => return "Null"
        };
    };

    private fn wrap(const string s, const char c1, const char c2) -> string {
        return `{c1}{s}{c2}`;
    };

    fn stringify(?const int indent_) -> string {
        const let indent = 1 * indent_.or(0); // If 0, there will never be any indentation
        const let nextIndent = if indent > 0 indent + 1 else 0;
        const let nl = if indent > 0 "\n" else "";
        mutable string indentStr = "";
        for int i = 0; i < indent; i++ {
            indentStr = `{indentStr}  `;
        };
        
        match my {
            String(s) => {
                const let value = my.wrap(s, '"', '"');
                return `{indentStr}{value}`;
            },
            Number(n) => return `{indentStr}{n}`,
            Boolean(b) => return `{indentStr}{b}`,
            List(list) => {
                const let v = match list.next() {
                    Some(value) => resolve value.get(), // unwrap the Box
                    None => return "[]"
                };
                mutable let builder = `[{nl}{indentStr}{v.stringify(nextIndent)}`;
                foreach item in list {
                    const let item = item.get(); // unwrap the Box

                    builder =  `{builder},{nl}{indentStr}{item.stringify(nextIndent)}`;
                };
                return `{builder}{nl}{indentStr}]`;
            },
            Object(map) => {
                mutable string builder = `{nl}{indentStr}`;
                let first = true;
                
                const let keys = map.keys();
                foreach key in keys {
                    const let value = map.get(key).expect(`Value {key} should be present`);
                    // value is a Box, so we need to unwrap it
                    const let value = value.get();
                    const let wrapKey = my.wrap(key, '"', '"');
                    if first {
                        first = false;
                    } else {
                        builder = `{builder},{nl}{indentStr}`;
                    };
                    builder = `{builder}{wrapKey}:`;
                    builder = builder + value.stringify(nextIndent);
                };
                mutable string sub1Indent = "";
                for int i = 0; i < indent - 1; i++ {
                    sub1Indent = `{sub1Indent}  `;
                };
                builder = `{builder}{nl}{indentStr}`;
                return my.wrap(builder, '{', '}');
            },
            Null => return `null`
        };


    };
};

// Wrap an unordered_map into a JSON Object variant.
export fn Object(const unordered_map::<Box::<JSON>> map) -> JSON {
    return new JSON->Object(map);
};

// Create a JSON String from an adr pointer.
export fn String(const adr s) -> JSON {
    if s == NULL return new JSON->Null();
    let v = malloc(st.len(s) + 1);
    memcpy(v, s, st.len(s) + 1);
    return new JSON->String(v);
};

// Create a JSON Number from a scalar integer value.
export fn Number(const int n) -> JSON {
    return new JSON->Number(n);
};

// Create a JSON Boolean from a bool.
export fn Boolean(const bool b) -> JSON {
    return new JSON->Boolean(b);
};

// Wrap an array of JSON boxes into the JSON List variant.
export fn List(const vector::<Box::<JSON>> list) -> JSON {
    return new JSON->List(list);
};

// Convenience creator for the JSON Null sentinel.
export fn Null() -> JSON {
    return new JSON->Null();
};

private fn parseInternal(const string json_) -> JSON!;
private fn formatParseContext(const string source, const int position) -> string;
private fn parseError(const string source, const string reason, const int position) -> Error;

private fn formatParseContext(const string source, const int position) -> string {
    const int length = source.len();
    int clamped = position;
    if clamped < 0 clamped = 0;
    if clamped > length clamped = length;
    int line = 1;
    int column = 1;
    int lineStart = 0;
    for int i = 0; i < clamped & i < length; i = i + 1 {
        const char current = source.at(i);
        if current == '\n' {
            line = line + 1;
            column = 1;
            lineStart = i + 1;
        } else {
            column = column + 1;
        };
    };
    string snippet = "";
    int idx = lineStart;
    while idx < length {
        const char c = source.at(idx);
        if c == '\n' {
            break;
        };
        snippet = `{snippet}{c}`;
        idx = idx + 1;
    };
    int caretOffset = clamped - lineStart;
    if caretOffset < 0 caretOffset = 0;
    string caretLine = "";
    for int i = 0; i < caretOffset; i = i + 1 {
        caretLine = `{caretLine} `;
    };
    caretLine = `{caretLine}^`;
    return `At line {line}, column {column}:\n{snippet}\n{caretLine}`;
};

private fn parseError(const string source, const string reason, const int position) -> Error {
    const let context = formatParseContext(source, position);
    return new Error(`JSON parse error: {reason}\n{context}`);
};

private fn isHexDigit(const char c) -> bool {
    if c >= '0' & c <= '9' return true;
    if c >= 'a' & c <= 'f' return true;
    if c >= 'A' & c <= 'F' return true;
    return false;
};

private fn parseStringValue(const string value) -> JSON! {
    string builder = "";
    int lastPos = value.tell();
    while true {
        match value.next() {
            Some(c) => {
                lastPos = value.tell();
                if c == '\\' {
                    const int escapePos = if value.tell() > 0 value.tell() - 1 else 0;
                    match value.next() {
                        Some(escapeChar) => {
                            lastPos = value.tell();
                            if escapeChar == '\"' {
                                const char quote = '\"';
                                builder = `{builder}{quote}`;
                            } else if escapeChar == '\\' {
                                const char backslash = '\\';
                                builder = `{builder}{backslash}`;
                            } else if escapeChar == '/' {
                                const char slash = '/';
                                builder = `{builder}{slash}`;
                            } else if escapeChar == 'b' {
                                const char backspace = io.toChar(8);
                                builder = `{builder}{backspace}`;
                            } else if escapeChar == 'f' {
                                const char formFeed = io.toChar(12);
                                builder = `{builder}{formFeed}`;
                            } else if escapeChar == 'n' {
                                const char newline = '\n';
                                builder = `{builder}{newline}`;
                            } else if escapeChar == 'r' {
                                const char carriageReturn = '\r';
                                builder = `{builder}{carriageReturn}`;
                            } else if escapeChar == 't' {
                                const char tab = '\t';
                                builder = `{builder}{tab}`;
                            } else if escapeChar == 'u' {
                                string hexDigits = "";
                                for int i = 0; i < 4; i = i + 1 {
                                    match value.next() {
                                        Some(hexChar) => {
                                            lastPos = value.tell();
                                            if !isHexDigit(hexChar) {
                                                const int invalidPos = if value.tell() > 0 value.tell() - 1 else 0;
                                                return parseError(value, "Invalid unicode escape sequence in string literal", invalidPos);
                                            };
                                            hexDigits = `{hexDigits}{hexChar}`;
                                        },
                                        None => return parseError(value, "Unterminated unicode escape sequence in string literal", value.len())
                                    };
                                };
                                const let unicodeValue = st.hex_toInt(hexDigits.cstr());
                                const char unicodeChar = io.toChar(unicodeValue);
                                builder = `{builder}{unicodeChar}`;
                            } else {
                                return parseError(value, `Invalid escape character '\\{escapeChar}' in string literal`, escapePos);
                            };
                        },
                        None => return parseError(value, "Unterminated escape sequence in string literal", escapePos)
                    };
                } else if c == '\"' {
                    return String(builder.cstr());
                } else if c == '\n' | c == '\r' {
                    const int newlinePos = if value.tell() > 0 value.tell() - 1 else 0;
                    return parseError(value, "Unescaped newline in string literal", newlinePos);
                } else {
                    builder = `{builder}{c}`;
                };
            },
            None => return parseError(value, "Unterminated string literal", lastPos)
        };
    };
};

private fn parseBooleanValue(const string value) -> JSON! {
    const int startPos = if value.tell() > 0 value.tell() - 1 else 0;
    if value.consume("rue") {
        return Boolean(true);
    } else if value.consume("alse") {
        return Boolean(false);
    };
    return parseError(value, "Invalid boolean literal (expected 'true' or 'false')", startPos);
};

private fn parseNullValue(const string value) -> JSON! {
    const int startPos = if value.tell() > 0 value.tell() - 1 else 0;
    if value.consume("ull") {
        return Null();
    };
    return parseError(value, "Invalid null literal (expected 'null')", startPos);
};

private fn parseArrayValue(const string value) -> JSON! {
    const let elements = new vector::<Box::<JSON>>();
    let v = value.peek();
    while true {
        const let parsed = parseInternal(value)!;
        const let boxed = box.wrap(parsed);
        elements.push_back($boxed);
        v = value.peek();
        if `{v.or('v')}` == "," {
            value.next();
        } else if `{v.or('v')}` == "]" {
            break;
        };
    };
    value.next();
    return new JSON->List(elements);
};

private fn parseObjectValue(const string value) -> JSON! {
    const let map = new unordered_map::<Box::<JSON>>();
    let v = value.peek();
    while true {
        if v.or('v') == '}' {
            value.next();
            return new JSON->Object(map);
        };

        const let key = match parseInternal(value)!.asString() {
            Ok(s) => s,
            Err(e) => return parseError(value, `Expected string key in JSON object: {e.toString()}`, value.tell())
        };
        const int colonPos = value.tell();
        const let colonOption = value.next();
        if colonOption.isNone() {
            return parseError(value, "Expected ':' after key in JSON object but reached end of input", value.len());
        };
        const let colon = colonOption.unwrap();
        if colon != ':' {
            return parseError(value, `Expected ':' after key in JSON object but found '{colon}'`, colonPos);
        };
        const let parsedVal = parseInternal(value)!;
        map.set(key, box.wrap(parsedVal));
        while st.char_isWhiteSpace(value.peek().or('n')) v = value.next();
        v = value.peek();
        if v.isNone() {
            return parseError(value, "Expected ',' or '}' in JSON object but reached end of input", value.len());
        };
        const let nextChar = v.unwrap();
        if nextChar == ',' {
            value.next();
            while st.char_isWhiteSpace(value.peek().or('n')) v = value.next();
            v = value.peek();
        } else if nextChar == '}' {
            value.next();
            return new JSON->Object(map);
        } else {
            return parseError(value, `Unexpected character '{nextChar}' in JSON object; expected ',' or '}'`, value.tell());
        };
    };
};

private fn parseInternal(const string json_) -> JSON! {
    foreach c in json_ {
        if st.char_isWhiteSpace(c) continue;
        if c == '\"' return parseStringValue(json_);
        if st.char_isDigit(c) {
            int num = io.toInt(c);
            while st.char_isDigit(json_.peek().or('v')) {
                match json_.next() {
                    Some(nc) => num = (num * 10) + io.toInt(nc),
                    None => break
                };
            };
            return Number(num);
        };
        if c == 't' | c == 'f' return parseBooleanValue(json_);
        if c == 'n' return parseNullValue(json_);
        if c == '[' return parseArrayValue(json_);
        if c == '{' return parseObjectValue(json_);

        const int position = if json_.tell() > 0 json_.tell() - 1 else 0;
        return parseError(json_, `Unexpected character '{c}'`, position);
    };
    return parseError(json_, "Unexpected end of input", json_.len());
};

// Parse a string buffer into a JSON document, returning Result semantics.
export fn parse(const string jsonStr) -> JSON! {
    return parseInternal(jsonStr);
};
