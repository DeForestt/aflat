.needs <std>
.needs <std>
import string from "String";
import result from "Utils/result";
import option from "Utils/option";
import vector from "Collections/Vector";
import unordered_map from "Collections/unordered_map";
import {Some, None, optionWrapper} from "Utils/option" under opt;
import {accept, reject, resultWrapper} from "Utils/result" under res;
import {print} from "String" under str;
import Box from "Memory";
import Error from "Utils/Error";

union JSON {
    String(adr),
    Number(int),
    Boolean(bool),
    List(vector::<Box::<JSON>>),
    Object(unordered_map::<Box::<JSON>>),
    Null

    fn get(const string key) -> JSON? {
        match my {
            Object(map) => {
                match map.get(key.cstr()) {
                    Some(value) => return value.get(), // unwrap the Box
                    None => return NULL // null will become None
                }
            },
            _ => return NULL,
        };
    };

    fn set(const string key, const JSON value) -> JSON! {
        match my {
            Object(map) => {
                map.set(key.cstr(), new Box::<JSON>(value));
                return my;
            },
            _ => return new Error("JSON is not an Object")
        }
    };

    fn asString() -> adr! {
        match my {
            String(s) => return s,
            _ => return new Error("JSON is not a String")           
        }
    };

    fn asNumber() -> int! {
        match my {
            Number(n) => return n,
            _ => return new Error("JSON is not a Number")
        }
    };

    fn asBoolean() -> bool! {
        match my {
            Boolean(b) => return b,
            _ => return new Error("JSON is not a Boolean")
        }
    };

    fn asList() -> vector::<Box::<JSON>>! {
        match my {
            List(list) => return list,
            _ => return new Error("JSON is not a List"),
        }
    }; 

    fn asObject() -> unordered_map::<Box::<JSON>>! {
        match my {
            Object(map) => return map,
            _ => return new Error("JSON is not an Object")
        }
    };

    fn isNull() -> bool {
        match my {
            Null => return true,
            _ => return false
        }
    };

    fn toString() -> string {
        match my {
            String(s) => return `String({s})`,
            Number(n) => return `Number({n})`,
            Boolean(b) => return `Boolean({b})`,
            List(list) => return `List({list})`,
            Object(map) => return `Object({map})`,
            Null => return "Null"
        };
    };

    private fn wrap(const string s, const char c1, const char c2) -> string {
        return `{c1}{s}{c2}`;
    };

    fn stringify(?const int indent_) -> string {
        const let indent = 1 * indent_.or(0); // If 0, there will never be any indentation
        const let nl = if indent > 0 "\n" else " ";
        mutable string indentStr = "";
        for int i = 0; i < indent; i++ {
            indentStr = `{indentStr}  `;
        };
        
        match my {
            String(s) => {
                const let value = my.wrap(s, '"', '"');
                return `{indentStr}{value}`;
            },
            Number(n) => return `{indentStr}{n}`,
            Boolean(b) => return `{indentStr}{b}`,
            List(list) => {
                const let v = match list.next() {
                    Some(value) => resolve value.get(), // unwrap the Box
                    None => return "[]"
                };
                mutable let builder = `[{nl}{indentStr}{v.stringify(indent + 1)}`;
                foreach item in list {
                    const let item = item.get(); // unwrap the Box

                    builder =  `{builder},{nl}{indentStr}{item.stringify(indent + 1)}`;
                };
                return `{builder}{nl}{indentStr}]`;
            },
            Object(map) => {
                mutable string builder = `{nl}{indentStr}`;
                let first = true;
                
                const let keys = map.keys();
                foreach key in keys {
                    const let value = map.get(key).expect(`Value {key} should be present`);
                    // value is a Box, so we need to unwrap it
                    const let value = value.get();
                    const let wrapKey = my.wrap(key, '"', '"');
                    if first {
                        first = false;
                    } else {
                        builder = `{builder},{nl}{indentStr}`;
                    };
                    builder = `{builder}{wrapKey}: `;
                    builder = builder + value.stringify(indent + 1  );
                };
                mutable string sub1Indent = "";
                for int i = 0; i < indent - 1; i++ {
                    sub1Indent = `{sub1Indent}  `;
                };
                builder = `{builder}{nl}{indentStr}`;
                return my.wrap(builder, '{', '}');
            },
            Null => return `null`
        };


    };
};

export fn Object(const unordered_map::<Box::<JSON>> map) -> JSON {
    return new JSON->Object(map);
};

export fn String(const adr s) -> JSON {
    return new JSON->String(s);
};

export fn Number(const int n) -> JSON {
    return new JSON->Number(n);
};

export fn Boolean(const bool b) -> JSON {
    return new JSON->Boolean(b);
};

export fn List(const vector::<Box::<JSON>> list) -> JSON {
    return new JSON->List(list);
};

export fn Null() -> JSON {
    return new JSON->Null();
};