.needs <asm>
.needs <std>

class Process{
    private int pid;
    private adr foo;

    Process init(adr foo);
    int start(* adr args);
    bool isRunning();
    int getPid();
};

class Pipe {
    int in;
    int out;
    int write(adr buf, int len);
    int read(adr buf, int len);
    Pipe init();
};

class FD {
  public int out;
  public int in;
};

Process init@Process(adr bar){
    my.foo = bar;
    my.pid = 0;
};

int start@Process(adr args){
    my.pid = sys_fork();
    adr bar = my.foo;
    if(my.pid == 0){
        bar(args);
        sys_exit(0);
    };
    return 0;
};

int getPid@Process(){
    return my.pid;
};


bool isRunning@Process(){
    int status = sys_kill(my.pid, 0); // 0 means no signal
    return status >= 0;
};

Process newProcess(adr foo){
    Process p = malloc(Process);
    if(p == #0){
        return NULL;
    };
    p.init(foo);
    return p;
};

Pipe init@Pipe(){
    FD fd = FD();
    sys_pipe(fd);
    my.out = fd.out;
    my.in = fd.in;
};

int read@Pipe(adr buf, int size){
    int fd;
    fd = my.out;
    int ret = sys_read(fd, buf, size);
    return ret;
};

int write@Pipe(adr buf, int size){
    int fd;
    fd = my.in;
    int ret = sys_write(fd, buf, size);
    return ret;
};

Pipe newPipe(){
    Pipe p = malloc(Pipe);
    p.init();
    return p;
};

export int exit(int status){
    sys_exit(status);
    return 0;
};

export int wait(Process p){
    sys_wait(p.getPid(), NULL, 0, NULL);
    return 0;
};