.needs <std>

import string from "String";
import List from "Collections";
import {fPrint} from "io" under io;
import Error from "Utils/Error";
import Render from "Utils/Error/Render";
import Result from "Utils/Result";
import Option from "Utils/Option";
import { some, none } from "Utils/Option" under opt;
import { accept, reject } from "Utils/Result" under pt;

class ParseError signs Error {
    const string message = message.copy();

    fn stdErrorMessage() -> Render {
        return `{my._typeName}: {my.message}`;
    };

    fn init(const string message) -> Self {
        return my;
    };
};

class Spec {
    string long = "";
    string short = "";
    bool needsValue = false;
    string description = "";
    string defaultVal = "";

    fn init(const string long, const string short, const bool needsValue, const string description, const string defaultVal) -> Self {
        my.long = long;
        my.short = short;
        my.needsValue = needsValue;
        my.description = description;
        my.defaultVal = defaultVal;
        return my;
    };
};

class Parsed {
    Spec spec = new Spec("", "", false, "", "");
    string value = "";

    fn init(const Spec spec, const string value) -> Self {
        my.spec = spec;
        my.value = value;
        return my;
    };
};

class ArgsList {
    List specs = new List(Spec);
    List parsed = new List(Parsed);
    List extras = new List(string);
    string progName = "";

    fn init(const int argc, const adr argv) -> Self {
        const adr[0] args = argv;
        my.progName = args[0];
        for int i = 1; i < argc; i++ {
            const string cur = args[i];
            if cur.at(0) == '-' {
                bool longForm = cur.at(1) == '-';
                const string name = if longForm cur.subString(2, cur.len()) else cur.subString(1, cur.len());
                Option found = my.findSpec(name);
                if found.isSome() {
                    const Spec sp = found.or(new Spec("", "", false, "", ""));
                    if sp.needsValue {
                        if i + 1 < argc {
                            const string val = args[i + 1];
                            my.parsed.pushBack(Parsed(sp, val));
                            i++;
                        } else {
                            io.fPrint("Missing value for %s\n", {cur});
                            return NULL;
                        };
                    } else {
                        my.parsed.pushBack(Parsed(sp, sp.defaultVal));
                    };
                } else {
                    io.fPrint("Unknown option %s\n", {cur});
                    return NULL;
                };
            } else {
                my.extras.pushBack(cur.copy());
            };
        };
        return my;
    };

    fn addOption(const string long, const string short, const bool needsValue, const string description, const string defaultVal) -> void {
        my.specs.pushBack(Spec(long, short, needsValue, description, defaultVal));
    };

    private fn findSpec(const string name) -> Option {
        return my.specs.findFirst([const Spec s, const string n] => return s.long == n | s.short == n, name);
    };

    fn get(const string name) -> Result {
        return my.parsed.findFirst([const Parsed p, const string n] => return p.spec.long == n | p.spec.short == n, name).resolve(
            [const Parsed p] => return pt.accept(p),
            [] => return pt.reject(new ParseError("Arg does not exist"))
        );
    };

    fn has(const string name) -> bool {
        return my.get(name).match({
            "ok": [] => return true,
            "_": [] => return false
        });
    };

    fn help() -> string {
        mutable string msg = new string("Usage: ");
        msg = msg + my.progName + " [options]\n";
        my.specs.forEach([const Spec s, const int i, const string m] => {
            m = m + "  -" + s.short + ", --" + s.long;
            if s.needsValue {
                m = m + " <val>";
            };
            if s.description != "" {
                m = m + ": " + s.description;
            };
            m = m + "\n";
        }, msg);
        return msg;
    };
};
