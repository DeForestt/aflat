.needs <std>
import string from "String";
import {str_at} from "strings" under st;
import { print } from "String" under str;
import unordered_map from "Collections/unordered_map";
import Error from "Utils/Error";
import Option from "Utils/Option";
import option from "Utils/option";
import Scroller from "Collections/Scroller";
import vector from "Collections/Vector";
import List from "Collections";
import {Some, None, optionWrapper} from "Utils/option" under opt;
import result from "Utils/result";
import {accept, reject, resultWrapper} from "Utils/result" under res;

union CLAValue {
	String(string),
	Number(int),
	Boolean(bool),
	None

	fn getString() -> string! {
		match my {
			String(s) => return s,
			Number(n) => return res.reject::<string>(new Error("Expected String, got Number")),
			Boolean(b) => return res.reject::<string>(new Error("Expected String, got Boolean")),
			None => return res.reject::<string>(new Error("No value present"))
		}
	};

	fn toString() -> string {
		match my {
			String(s) => return `{s}`,
			Number(n) => return `{n}`,
			Boolean(b) => return `{b}`,
			None => return "None"
		}
	}
};

class Argument {
	const string longName = longName;
	const string shortName = shortName;
	const string description = description;
	const string defaultValue = defaultValue.or("false");

	fn init(adr longName, adr shortName, adr description, ?adr defaultValue) -> Self {
		return my;
	};

	fn toString() -> string {
		return `--{my.longName}, -{my.shortName}: {my.description} (default: {my.defaultValue})`;
	};
};

class CLAInternalArgs {
	unordered_map::<Argument> arguments;
	string tag;
};

class CommandLineArgs {
	const int argc = argc;
	const adr argv = argv;
	mutable string programName = "";

	mutable vector::<Argument> arguments = NULL;
	mutable vector::<CLAValue> untagedValues = [];
	const unordered_map::<CLAValue> values = {};
	
	mutable bool built = false;

	fn with_arguments(vector::<Argument> &&args) -> Self {
		if my.built {
			panic("CommandLineArgs has already been built. Cannot add more arguments.");
		};
		my.arguments = args;
		return my;
	};

	fn init(int argc, adr argv) -> Self {
		return my;
	};

	fn parse() -> bool! {
		adr[0] args = my.argv;
		my.programName = args[0];
		mutable int i = 1;
		while i < my.argc {
			mutable let found = false;
			const string arg = new string(args[i]);
			foreach argument in my.arguments {
				if `--{argument.longName}` == arg {
					found = true;
					if i + 1 < my.argc {
						i = i + 1;
						if st.str_at(args[i], 0) == '-' {
							my.values.set(argument.longName.cstr(), new CLAValue->Boolean(true));
							i = i - 1; // Adjust index since we consumed an argument
						} else {
							my.values.set(argument.longName.cstr(), new CLAValue->String(args[i]));
						};
					} else {
						my.values.set(argument.longName.cstr(), new CLAValue->Boolean(true));
					};
				} else if `-{argument.shortName}` == arg {
					found = true;
					if i + 1 < my.argc {
						i = i + 1;
						if st.str_at(args[i], 0) == '-' {
							my.values.set(argument.longName.cstr(), new CLAValue->Boolean(true));
							i = i - 1; // Adjust index since we consumed an argument
						} else {
							my.values.set(argument.longName.cstr(), new CLAValue->String(args[i]));
						};
					} else {
						my.values.set(argument.longName.cstr(), new CLAValue->Boolean(true));
					};
				};
			};
			
			if !found {
				if st.str_at(args[i], 0) == '-' {
					return res.reject::<bool>(new Error(`Unknown Command Line Tag {args[i]}`))
				} else {
					my.untagedValues.push_back(new CLAValue->String(args[i]));
				};
			};

			i = i + 1;
		};
		return true;
	};

	fn printHelp() -> void {
		str.print(`Usage: {my.programName} [options]\n`);
		foreach arg in my.arguments {
			str.print(`\t{arg}\n`);
		};
	};

	fn popCommand() -> CLAValue? {
		return my.untagedValues.pop_back();
	};

	fn hasTag(string tag) -> bool {
		return my.values.has(tag.cstr());
	};

	fn getTag(string tag) -> CLAValue? {
		my.values.get(tag.cstr());
	};
};