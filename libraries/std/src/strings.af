.needs <io.gs>
.needs <std>
.needs <math.gs>

char ascii(int input){
	adr caster = ?input;
	return caster as char;
};

int len(adr input){
	char null = ascii(0);
    int i = 0;
	while(input as char != null ){
        i = i + 1;
		input = input + 1;
	};
	return i;
};

int str_comp(adr str1, adr str2){
        int len1 = len(str1);
        int len2 = len(str2);

        if(len1 != len2){ return 0; };

        int i = 0;

        while(i < len1){
                i = i + 1;
                char ch1 = str1 as char;
                char ch2 = str2 as char;
                if (ch1 != ch2){return 0;};
                str2 = str2 + 1;
                str1 = str1 + 1;
        };

        return 1;
};

int str_concat(adr str1, adr str2, adr pointer){
    char null = ascii(0);
    char loader;
    while(str1 as char != null){
        loader = str1 as char;
        pointer =: loader;
        str1 = str1 + 1;
        pointer = pointer + 1;
    };

    while(str2 as char != null){
        loader = str2 as char;
        pointer =: loader;
        str2 = str2 + 1;
        pointer = pointer + 1;
    };

    pointer =: null;

    return 0;
};

int str_toInt(adr input){
    int mul = 1;
    char ch1 = input as char;
    if(ch1 == '-'){
        mul = -1;
        input = input + #1;
    };
    
    char null = ascii(0);
    int factor = 0;
    int size = len(input);
    int result = 0;
    int i = size - 1;
    while(i > -1){
        factor = exp(10, i);
        char ch2 = input as char;
        int num = toInt(ch2);
        factor = factor * num;
        result = result + factor;
        i = i - 1;
        input = input + 1;
    };
    result = result * mul;
    return result;
};

/*
 * functionName: int_toStr
 * description: converts an integer to a string
 * arguments: int input, adr buffer
 * returns: 0;
 */
int int_toString(int input, adr buffer){
        int h = 0;
        int ten = 10;
        int factor = 0;
        int i = 0;
        char null = ascii(0);

        if (input == 0){
                buffer =: '0';
                buffer =: null;
                buffer = buffer + #1;
                return 0;
        };

        if (input < 0){
                buffer =: '-';
                buffer = buffer + #1;
                input = input * -1;
        };

        h = input * 1;
        while (h != 0){
                h = h / ten;
                i = i + 1;
        };

        i = i - 1;

        char out = ' ';
        while (i > -1){
                factor = exp(10, i);
                h = input / factor;
                out = toChar(h);
                buffer =: out;
                buffer = buffer + #1;
                h = h * factor;
                input = input - h;
                i = i - 1;
        };
        buffer =: null;
        return 0;
};

int str_find(adr in, char find){
    int i = 0;
    int len = len(in);
    while(i < len){
        in = in + 1;
		char b = in as char;
        if(b == find){return i};
        i = i + 1;
    };
    return -1;
};

/*
 * Function name: str_split
 * Description:   Splits a string into an array of strings
 * Arguments:     str - the string to split
 *                sep - the separator
 * 			      buff1 - buffer for the first part of the split
 *                buff2 - buffer for the second part of the split
 * Returns:       0 on success, -1 on failure
 */
int str_split(adr str, char sep, adr buff1, adr buff2){
	char null = ascii(0);
	char check = str as char;

	while(check != sep){
		if (check == null){
			return -1;
		};

		if (check != sep){
			buff1 =: check;
		};
		str = str + 1;
		buff1 = buff1 + 1;
		check = str as char;
	};
    buff1 =: null;
	
	str = str + 1;
	if (str as char == null){
		return -1;
	};
	str_concat("", str, buff2);
	return 0;
};

float charToFloat(char a){
    float result = 0.00;
    if (a == '0'){result = 0.00;};
    if (a == '1'){result = 1.00;};
    if (a == '2'){result = 2.00;};
    if (a == '3'){result = 3.00;};
    if (a == '4'){result = 4.00;};
    if (a == '5'){result = 5.00;};
    if (a == '6'){result = 6.00;};
    if (a == '7'){result = 7.00;};
    if (a == '8'){result = 8.00;};
    if (a == '9'){result = 9.00;};
    return result;
};

int str_toFloat(adr input){
	char 20 whole;
	char 20 decimal;

	str_split(input, '.', ?whole, ?decimal);
	int len = len(?whole);
	len = len - 1;

	float result = 0.00;
	int i = 0;
	float factor = 1.0;
	while (i < len){
		factor = factor * 10.0;
		i = i + 1;
	};
	i = 0;

	float temp = 0.00;
	char nullChar = ascii(0);
	char inChar = input as char;
	float ten = 10.0;
	while (inChar!= nullChar){
		if (inChar == '.'){
			factor = 0.1;
		};

		if (inChar != '.'){
			temp = charToFloat(inChar);
			float adder = result + 0.00;
			result = temp * factor;
			result = result + adder;
			factor = factor / ten;
		};

		input = input + 1;
		inChar = input as char;
		i = i + 1;
	};
	adr cast = ?result;
	float cleas = 0.0;
	cleas = cleas * cleas;
	int ret = cast as int;
	return ret;
};

int sPrintFloat(adr input){
	printFloat(input);
	return 0;
};

int float_toString(adr input, adr obuff, int signed){

	if(input == #0){
		return -1;
	};

	int percision = 6;

	adr mySign = "";
	// as input into a new int
	int inputInt = input as int;
	if (inputInt == 0){
		printInt(0);
		return 0;
	};

	//get the sign bit of the float
	
	int sign = inputInt >> 31;
	
	//get the exponent of the float
	
	int exponent = inputInt >> 23;
	exponent = exponent & 255;
	exponent = exponent - 127;


	//get the mantissa of the float
	int mantissa = inputInt & 8388607;


	//load the manissa bits into a linked list
	Bit head = newBit(0);

	//printInt(head.value);
	Bit current;
	current = head;
	int j = 0;
	while(j < 23){
		Bit new = newBit(mantissa & 1);
		//printInt(new.value);
		current.next = new;
		new.last = current;
		current = new;
		mantissa = mantissa >> 1;
		j = j + 1;
	};
	
	Bit new = newBit(1);
	current.next = new;
	new.last = current;
	current = new;

	//find last element in the list
	current = head;
	while(current.next != #0){
		current = current.next;
	};


	//print the sign bit
	if(sign != 0){
		mySign = "-";
	};
	if(signed == 1){
		if(sign == 0){
			mySign = "+";
		};
	};
	//convert bits to an int
	int factor;
	int result;

	factor = exponent;
	int i = 0;
	while(factor > -1){
		if (current.value == 1){
			int append = exp(2, factor);
			result = result + append;
		};
		current = current.last;
		factor = factor - 1;
		i = i + 1;
	};

	factor = exp(10, percision);
	factor = factor * 5;
	int two = 2;
	int decimalPlacess = 0;

	while(i < 23){
		if (current.value == 1){
			decimalPlacess = decimalPlacess + factor;
		};
		current = current.last;
		factor = factor / two;
		i = i + 1;
	};

	push ?mySign; printInt(result); print("."); printInt(decimalPlacess);
    char 10 rstring;
    int_toString(result, ?rstring);
    str_concat(mySign, ?rstring, obuff);
    str_concat(obuff, ".", obuff);
    int_toString(decimalPlacess, ?rstring);
    str_concat(obuff, ?rstring, obuff);
	
	return 0;	
};

adr str_subString(int start, int length, adr str, adr buff) {
	adr cleanStart = #0;
	cleanStart = ?start;
	adr go = cleanStart as int;
	str = str + go;

	adr point;
	point = buff;

	int i = 0;

	while (i < length) {
		char ch = str as char;
		point =: ch;
		point = point + #1;
		str = str + #1;
		i = i + 1;
	};
	point =: '\0';

	return buff;
};

adr str_reverse(adr in, adr buff){
	int length = len(in);
	adr buffPtr; buffPtr = buff;
	
	
	for {int i = length - 1;}
		(i > -1)
		{i = i - 1;}{
		
		adr pointer = in + i;
		
		char ch = pointer as char;
		buff =: ch;
		buff = buff + 1;
	};

	buff =: '\0';

	return buffPtr;
};

char str_at(adr str, int i){
	adr point = str + i;
	return point as char;
};

int str_forEach(adr s, adr foo, adr args){
	int len = len(s);
	for {int i = 0;}(i < len){i = i + 1;}{
		char c = str_at(s, i);
		int break = foo(c, i, args);
		if (break == 1) {
			return break;
		};
	};
	return 0;
};