.needs <std>
import Result from "Utils/Result";
import string from "String";
import Error from "Utils/Error";
import option from "Utils/option";
import Map from "Utils/Map";
import Iterator from "Collections/Iterator";
import Scroller from "Collections/Scroller";
import {Some, None, optionWrapper} from "Utils/option" under opt;
import result from "Utils/result";
import {accept, reject, resultWrapper} from "Utils/result" under res;
import tuple from "Collections/Tuple";
import {make_tuple} from "Collections/Tuple";
import {print} from "String" under str;
import Enumerator from "Collections/Enumerator";

types(T)
class vector {
    private mutable adr head = NULL;
    private int size = 0;
    private int count = 0;
    int iteratorIndex = 0;

    fn init(*const int size) -> Self {
        if size == 0 {
            my.size = 1; 
            my.head = malloc(T * my.size);
        };
        return my;
    };

    when (T is primitive and T is not adr)
    fn push_back(const T value) -> Self {
        if my.count == my.size {
            my.size = my.size * 2;
            my.head = realloc(my.head, T * my.size);
        };

        memcpy(my.head + (my.count * T), ?value, T);
        my.count = my.count + 1;
        return my;
    };

    when (T is not primitive or T is adr)
    fn push_back(const T &&value) -> Self {
        if my.count == my.size {
            my.size = my.size * 2;
            my.head = realloc(my.head, T * my.size);
        };

        memcpy(my.head + (my.count * T), value, T);
        my.count = my.count + 1;
        return my;
    };

    safe fn count() -> int {
        return my.count;
    };

    fn front() -> option::<T> {
        if my.count == 0 {
            return opt.None::<T>();
        };
        
        return my.get(0);
    };

    fn back() -> option::<T> {
        if my.count == 0 {
            return opt.None::<T>();
        };

        return my.get(my.count - 1);
    };

    when (T is primitive and T is not adr)
    fn pop_back() -> option::<T> {
        if my.count == 0 {
            return opt.None::<T>();
        };

        my.count = my.count - 1;
        const adr val = my.head + (my.count * T);
        return opt.Some::<T>(val as T);
    };

    when (T is not primitive or T is adr)
    fn pop_back() -> option::<T> {
        if my.count == 0 {
            return opt.None::<T>();
        };
        my.count = my.count - 1;
        const T val = my.head + (my.count * T);
        return opt.Some(val as T);
    };

    when (T is primitive and T is not adr)
    fn get(const int index) -> option::<T> {
        if index >= my.count | index < 0 {
            return opt.None::<T>();
        };
        const adr val = my.head + (index * T);
        return opt.Some(val as T);
    };

    when (T is adr or T is not primitive)
    fn get(const int index) -> option::<T> {
        if index >= my.count | index < 0 {
            return opt.None::<T>();
        };
        const T val = my.head + (index * T);
        return opt.Some(val);
    };


    fn _call(const int index) -> option::<T> {
        return my.get(index);
    };

    fn findFirst(const adr predicate, * const adr args) -> option::<T> {
        for int i = 0; i < my.count; i = i + 1 {
            const any val = my.get(i).expect(`Failed to get value at index {i} from vector`);
            const bool brk = predicate(val, args);
            if brk == true {
                return opt.Some::<T>(val);
            };
            return opt.None::<T>();
        };
    };

    when (T is not primitive or T is adr)
    fn set(const int index, const T &&value) -> result::<bool> {
        if index >= my.count {
            return res.reject::<bool>(new Error("Index out of bounds"));
        };
        memcpy(my.head + (index * T), value, T);
        return res.accept(true);
    };

    when (T is primitive and T is not adr)
    fn set(const int index, const T value) -> result::<bool> {
        if index >= my.count {
            return res.reject::<bool>(new Error("Index out of bounds"));
        };
        memcpy(my.head + (index * T), ?value, T);
        return res.accept(true);
    };

    fn next() -> option::<T> {
        const let val = my.get(my.iteratorIndex);
        my.iteratorIndex = my.iteratorIndex + 1;
        if my.iteratorIndex > my.count {
            my.iteratorIndex = 0; // Reset iterator index if it exceeds the count
        };
        return val;
    };

    fn stitch(immutable vector::<T> other) -> Self {
        const let totalCount = my.count() + other.count();
        const let totalSize = totalCount * T;
        if totalSize > my.size {
            my.size = totalSize;
            my.head = realloc(my.head, T * my.size);
        };
        memcpy(my.head + (my.count * T), other.head, other.count() * T);
        my.count = totalCount;
        return my;
    };

    fn reset() -> Self {
        my.iteratorIndex = 0;
        return my;
    };

    fn toString() -> string {
        return `vector(size={my.size}, count={my.count})`;
    }

    when (T is not primitive or T is adr)
    fn sort(const adr comparator) -> void {
        if my.count < 2 {
            return;
        };
        // Implement a simple bubble sort for demonstration purposes
        for int i = 0; i < my.count - 1; i = i + 1 {
            for int j = 0; j < my.count - i - 1; j = j + 1 {
                const adr a = my.head + (j * T);
                const adr b = my.head + ((j + 1) * T);
                if comparator(a, b) == true {
                    // Swap elements
                    const adr temp = malloc(T);
                    memcpy(temp, a, T);
                    memcpy(a, b, T);
                    memcpy(b, temp, T);
                    free(temp);
                };
            };
        };
    }

   when (T is primitive and T is not adr)
   fn sort(const adr comparator) -> void {
       if my.count < 2 {
           return;
       };
       // Implement a simple bubble sort for demonstration purposes
       for int i = 0; i < my.count - 1; i = i + 1 {
           for int j = 0; j < my.count - i - 1; j = j + 1 {
               const adr a = my.head + (j * T);
               const adr b = my.head + ((j + 1) * T);
               const T a_val = a as T;
               const T b_val = b as T;
               const bool c = comparator(a_val, b_val);
               if c == true {
                    a =: b_val;
                    b =: a_val;
               };
           };
       };
   }
};
