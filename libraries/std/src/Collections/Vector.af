.needs <std>
import List from "Collections";
import Result from "Utils/Result";
import Error from "Utils/Error";
import option from "Utils/option";
import Map from "Utils/Map";
import Iterator from "Collections/Iterator";
import Scroller from "Collections/Scroller";
import {Some, None} from "Utils/option" under opt;
import result from "Utils/result";
import {accept, reject, resultWrapper} from "Utils/result" under res;

types(T)
class vector {
    private List inner = new List(T, size);
    int iteratorIndex = 0;

    fn init(*const int size) -> Self {
        return my;
    };

    fn push_back(const T &&value) -> Self {
        my.inner.pushBack(value);
        return my;
    };

    fn count() -> int {
        return my.inner.getCount();
    };

    fn pop_back() -> option::<T> {
        const let ret = my.inner.popBack();
        return ret.match({
            "some": fn (const T value) {
                return opt.Some::<T>(value);
            },
            "none": fn () {
                return opt.None::<T>();
            }
        });
    };

    fn get(const int index) -> option::<T> {
        const let ret = my.inner.get(index);
        return ret.match({
            "ok": fn (const T value) {
                return opt.Some::<T>(value);
            },
            "_": fn () {
                return opt.None::<T>();
            }
        });
    };

    fn _call(const int index) -> option::<T> {
        return my.get(index);
    };

    fn push_value(const T value) -> Self {
        my.inner.pushValue(value);
        return my;
    };

    fn findFirst(const adr predicate, * const adr args) -> option::<T> {
        const let ret = my.inner.findFirst(predicate, args);
        return ret.match({
            "some": fn (const T value) {
                return opt.Some::<T>(value);
            },
            "none": fn () {
                return opt.None::<T>();
            }
        });
    };

    fn set(const int index, const T &&value) -> result::<bool> {
        if index >= my.inner.getCount() {
            return res.reject::<bool>(new Error("Index out of bounds"));
        }
        my.inner.set(index, value);
        return res.accept(true);
    };
    
    fn scroll() -> Scroller {
        return my.inner.scroll();
    };

    fn next() -> option::<T> {
        const let val = my.get(my.iteratorIndex);
        my.iteratorIndex = my.iteratorIndex + 1;
        return val;
    };

    fn reset() -> Self {
        my.iteratorIndex = 0;
        return my;
    };
};
