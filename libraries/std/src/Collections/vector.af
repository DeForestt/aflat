.needs <std>

import List from "Collections";
import option from "Utils/option";
import { some, none } from "Utils/option" under opt;
import Option from "Utils/Option"; 
import Result from "Utils/Result";
import string from "String";

types(T)
safe dynamic class vector {
    private List inner = new List(T);

    fn init(*const int capacity) -> Self {
        if capacity != 0 {
            my.inner = new List(T, capacity);
        };
        return my;
    };

    fn pushBack(const T value) -> int {
        return my.inner.pushBack(value);
    };

    fn get(const int index) {
        return my.inner.get(index).resolve(option.some::<T>, option.none::<T>);
    };

    fn popBack() {
        const Option raw = my.inner.popBack();
        return raw.resolve(option.some::<T>, option.none::<T>);
    };

    fn back() {
        const Option raw = my.inner.back();
        return raw.resolve(option.some::<T>, option.none::<T>);
    };

    fn size() -> int {
        return my.inner.getCount();
    };

    fn toString() -> string {
        return my.inner.toString();
    };
};
