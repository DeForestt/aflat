.needs <std> 
import string from "String";

class RefCounted {
	private mutable int refCount = 0;
	private mutable bool locked = false;

	fn get() -> Self {
		my.refCount = my.refCount + 1;
		return my;
	};  

	fn endScope() {
		if my.locked return;
		my.refCount = my.refCount - 1;
		if (my.refCount <= 0) {
			delete my;
		};
	};

	fn lock() {
		my.locked = true;
	};

	fn unlock() {
		my.locked = false;
	};
};

types(T)
class Box {
	private mutable T value = value;

	fn init(const T value) -> Self {
		return my;
	};

	fn get() -> T {
		return my.value;
	};

	fn _set(const T &&value) -> Self {
		my.value = value;
		return my;
	};

	when(T has toString)
	fn toString() -> string {
		return `Box: {my.value}`;
	};

	when(T missing toString)
	fn toString() -> string {
		return `Box: {__typeName__}`; // just use the typeName for toString
	};

};

types(T)
export fn wrap(const T &&value) -> Box::<T> {
	return new Box::<T>(value);
};